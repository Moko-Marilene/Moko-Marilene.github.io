<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="DEBA Franck">
<meta name="author" content="KOUGOUM Marilene">

<title>Gestion des risques multiples: Théorie des copules –</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>



<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../logo.png" alt="" class="navbar-logo light-content">
    <img src="../../logo.png" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title"></span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../finance_quant/index.html"> 
<span class="menu-text">Finance Quantitative</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../risques/index.html"> 
<span class="menu-text">Risque &amp; Régulation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../modelisation-stat.qmd"> 
<span class="menu-text">Modélisation stat</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../data-science.html"> 
<span class="menu-text">Data science</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../articles-ressources.qmd"> 
<span class="menu-text">Ressources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">À propos</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#modèles-de-courbe-de-taux" id="toc-modèles-de-courbe-de-taux" class="nav-link active" data-scroll-target="#modèles-de-courbe-de-taux">Modèles de Courbe de Taux</a>
  <ul class="collapse">
  <li><a href="#objectif-du-projet" id="toc-objectif-du-projet" class="nav-link" data-scroll-target="#objectif-du-projet">Objectif du projet</a></li>
  <li><a href="#contenu" id="toc-contenu" class="nav-link" data-scroll-target="#contenu">Contenu</a>
  <ul class="collapse">
  <li><a href="#reconstruction-de-la-courbe-des-taux-zéro-coupon" id="toc-reconstruction-de-la-courbe-des-taux-zéro-coupon" class="nav-link" data-scroll-target="#reconstruction-de-la-courbe-des-taux-zéro-coupon">1. Reconstruction de la courbe des taux zéro-coupon</a></li>
  <li><a href="#valorisation-des-instruments-de-marché" id="toc-valorisation-des-instruments-de-marché" class="nav-link" data-scroll-target="#valorisation-des-instruments-de-marché">2. Valorisation des instruments de marché</a></li>
  <li><a href="#modèle-de-pricing-des-caplets-et-swaptions" id="toc-modèle-de-pricing-des-caplets-et-swaptions" class="nav-link" data-scroll-target="#modèle-de-pricing-des-caplets-et-swaptions">3. Modèle de pricing des caplets et swaptions</a></li>
  <li><a href="#modèle-de-hull-white" id="toc-modèle-de-hull-white" class="nav-link" data-scroll-target="#modèle-de-hull-white">4. Modèle de Hull &amp; White</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#reconstitution-dune-courbe-de-taux-zéro-coupon" id="toc-reconstitution-dune-courbe-de-taux-zéro-coupon" class="nav-link" data-scroll-target="#reconstitution-dune-courbe-de-taux-zéro-coupon">Reconstitution d’une courbe de taux zéro-coupon</a>
  <ul class="collapse">
  <li><a href="#formules-de-valorisation-des-taux-de-marché" id="toc-formules-de-valorisation-des-taux-de-marché" class="nav-link" data-scroll-target="#formules-de-valorisation-des-taux-de-marché">Formules de valorisation des taux de marché</a></li>
  <li><a href="#construction-de-la-courbe-des-taux-zéro-coupon" id="toc-construction-de-la-courbe-des-taux-zéro-coupon" class="nav-link" data-scroll-target="#construction-de-la-courbe-des-taux-zéro-coupon">Construction de la courbe des taux zéro-coupon</a></li>
  <li><a href="#construction-de-la-courbe-des-taux-forward" id="toc-construction-de-la-courbe-des-taux-forward" class="nav-link" data-scroll-target="#construction-de-la-courbe-des-taux-forward">Construction de la courbe des taux forward</a></li>
  </ul></li>
  <li><a href="#valorisation-de-swaptions-et-de-caplets" id="toc-valorisation-de-swaptions-et-de-caplets" class="nav-link" data-scroll-target="#valorisation-de-swaptions-et-de-caplets">Valorisation de swaptions et de caplets</a></li>
  <li><a href="#le-modèle-de-hullwhite" id="toc-le-modèle-de-hullwhite" class="nav-link" data-scroll-target="#le-modèle-de-hullwhite">Le Modèle de Hull&amp;White</a>
  <ul class="collapse">
  <li><a href="#du-modèle-hjm-vers-le-modèle-hullwhite" id="toc-du-modèle-hjm-vers-le-modèle-hullwhite" class="nav-link" data-scroll-target="#du-modèle-hjm-vers-le-modèle-hullwhite">Du modèle HJM vers le modèle Hull&amp;White</a></li>
  <li><a href="#hypothèses-du-modèle-hullwhite" id="toc-hypothèses-du-modèle-hullwhite" class="nav-link" data-scroll-target="#hypothèses-du-modèle-hullwhite">Hypothèses du modèle Hull&amp;White</a></li>
  <li><a href="#construction-de-la-formule-zéro-coupon" id="toc-construction-de-la-formule-zéro-coupon" class="nav-link" data-scroll-target="#construction-de-la-formule-zéro-coupon">Construction de la formule zéro-coupon</a></li>
  <li><a href="#dynamique-des-taux-forwards" id="toc-dynamique-des-taux-forwards" class="nav-link" data-scroll-target="#dynamique-des-taux-forwards">Dynamique des taux forwards</a></li>
  <li><a href="#valorisation-des-instruments-de-calibration" id="toc-valorisation-des-instruments-de-calibration" class="nav-link" data-scroll-target="#valorisation-des-instruments-de-calibration">Valorisation des instruments de calibration</a></li>
  <li><a href="#calibration-du-modèle" id="toc-calibration-du-modèle" class="nav-link" data-scroll-target="#calibration-du-modèle">Calibration du modèle</a></li>
  <li><a href="#valorisation-dun-produit-structuré" id="toc-valorisation-dun-produit-structuré" class="nav-link" data-scroll-target="#valorisation-dun-produit-structuré">Valorisation d’un produit structuré</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Gestion des risques multiples: Théorie des copules</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>DEBA Franck </p>
             <p>KOUGOUM Marilene </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="modèles-de-courbe-de-taux" class="level1">
<h1>Modèles de Courbe de Taux</h1>
<section id="objectif-du-projet" class="level2">
<h2 class="anchored" data-anchor-id="objectif-du-projet">Objectif du projet</h2>
<p>Ce projet vise à explorer les concepts de base des modèles de courbe de taux, en abordant les sujets suivants :</p>
<ul>
<li>Reconstituer une courbe de taux zéro-coupon<br>
</li>
<li>Valoriser des instruments de taux dérivés (caplets, swaptions)<br>
</li>
<li>Explorer le modèle de Hull &amp; White pour la calibration et le pricing d’options de taux</li>
</ul>
<hr>
</section>
<section id="contenu" class="level2">
<h2 class="anchored" data-anchor-id="contenu">Contenu</h2>
<section id="reconstruction-de-la-courbe-des-taux-zéro-coupon" class="level3">
<h3 class="anchored" data-anchor-id="reconstruction-de-la-courbe-des-taux-zéro-coupon">1. Reconstruction de la courbe des taux zéro-coupon</h3>
<ul>
<li>Utilisation de la méthode du <strong>bootstrapping</strong> et de l’interpolation <strong>spline</strong> pour reconstruire la courbe des taux zéro-coupon à partir des données de marché.</li>
</ul>
</section>
<section id="valorisation-des-instruments-de-marché" class="level3">
<h3 class="anchored" data-anchor-id="valorisation-des-instruments-de-marché">2. Valorisation des instruments de marché</h3>
<ul>
<li>Valorisation des dérivés de taux comme les <strong>caplets</strong> et les <strong>swaptions</strong>.<br>
</li>
<li>Construction des <strong>courbes de taux forward</strong>.</li>
</ul>
</section>
<section id="modèle-de-pricing-des-caplets-et-swaptions" class="level3">
<h3 class="anchored" data-anchor-id="modèle-de-pricing-des-caplets-et-swaptions">3. Modèle de pricing des caplets et swaptions</h3>
<ul>
<li>Calcul des prix de marché à partir de la <strong>courbe zéro-coupon</strong>.<br>
</li>
<li>Comparaison des interpolations <strong>linéaire vs spline</strong> pour déterminer la méthode la plus adaptée à la valorisation.</li>
</ul>
</section>
<section id="modèle-de-hull-white" class="level3">
<h3 class="anchored" data-anchor-id="modèle-de-hull-white">4. Modèle de Hull &amp; White</h3>
<ul>
<li>Transition depuis le modèle <strong>HJM (Heath–Jarrow–Morton)</strong> vers le modèle <strong>Hull &amp; White</strong>.<br>
</li>
<li>Formulation mathématique du modèle et <strong>calibration</strong> à partir des données de marché.<br>
</li>
<li>Simulation <strong>Monte-Carlo</strong> pour la valorisation d’options structurées basées sur ce modèle.</li>
</ul>
<hr>
<div id="e55e6b15" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> interp1d, CubicSpline</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tabulate <span class="im">import</span> tabulate</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</section>
</section>
</section>
<section id="reconstitution-dune-courbe-de-taux-zéro-coupon" class="level1">
<h1>Reconstitution d’une courbe de taux zéro-coupon</h1>
<hr>
<section id="formules-de-valorisation-des-taux-de-marché" class="level2">
<h2 class="anchored" data-anchor-id="formules-de-valorisation-des-taux-de-marché">Formules de valorisation des taux de marché</h2>
<hr>
<ol type="1">
<li><p>Le tableau de l’énoncé (courbe de taux de marché) décrit une courbe de taux interbancaires.</p>
<p>En effet, les instruments qu’il contient, et desquels on derivera nos taux zero coupons pour differentes maturités, sont essentiellement des taux de marché monétaire (money market), des contrats futures et des swaps.</p></li>
<li><p>Ce tableau contient trois types d’instruments financiers:</p>
<ul>
<li><p><strong>Des Money market</strong> : Il s’agit des taux (monétaires) à court terme sur le marché interbancaire. Dans le contexte de notre exercice, il s’agit de taux Libor pour les maturités allant de 3 mois à 1 an.</p></li>
<li><p><strong>Des contrats futures de taux d’intérêt</strong> :Ce sont des instruments financiers négociés sur un marché réglementé, permettant aux acteurs du marché</p>
<p>de s’engager dès aujourd’hui sur l’évolution d’un taux d’intérêt futur à un niveau prédéfini. Ils sont utilisés aussi bien à des fins de couverture contre le risque de taux que pour la spéculation. Afin de limiter le risque de contrepartie, ces contrats sont sujets à des appels de marge quotidiens. La courbe de taux de marché présente des futures de taux d’intérêt avec des maturités comprises entre 1.25 et 2.75 ans.</p></li>
<li><p><strong>Des swaps de taux d’intérêts</strong>: Un swap de taux d’intérêt est un contrat entre deux parties visant à échanger des flux financiers basés sur un montant notionnel déterminé. Généralement, l’une des parties verse des paiements à taux fixe, tandis que l’autre paie des intérêts à taux variable, indexés sur un indice de référence (dans notre cas, le Libor). Cet échange suit un échéancier prédéfini et permet aux acteurs du marché de se couvrir contre le risque de taux d’intérêt ou d’optimiser leurs coûts de financement.</p>
<p>La courbe de taux de marché contient des Swaps dont les tenors vont de 3 à 30 ans</p></li>
</ul>
<p>\end{itemize}</p>
<p>Sous l’hypothèse d’absence d’opportunuité d’arbitrage ces instruments sont valorisés par les formules suivantes:</p>
<ul>
<li><p>Money Market (Taux libor): Etant donné une période d’intérêt <span class="math inline">\([T, T+\delta]\)</span>, la valeur du tau libor vu aujourd’hui est donnée par</p>
<p>$$</p>
<p><span class="math display">\[\begin{equation}

L_0(T,T+\delta) = \frac{1}{\delta} \left( \frac{B(0,T)}{B(0,T + \delta)} - 1 \right)

\end{equation}\]</span></p>
<p>$$</p></li>
<li><p>La valeur vue d’aujourd’hui du future de taux d’intérêt pour la date de départ <span class="math inline">\(T\)</span> et de tenor <span class="math inline">\(T+\delta\)</span> est donnée par:</p>
<p>$$</p>
<p><span class="math display">\[\begin{equation}

F(0,T, T+\delta) = 1 - L_0(T,T+\delta)

\end{equation}\]</span></p>
<p>$$</p></li>
<li><p>Etant donné les échéanciers $(t_i)_{i=0,…,m} $(pour la jambe fixe) et <span class="math inline">\((t_j)_{j=0,...,n}\)</span> (pour la jambe flottante), on définit le swap à départ <span class="math inline">\(T_0 = t_0 = \tilde{t}_0\)</span> et de maturité <span class="math inline">\(T_n = t_m = \tilde{t}_n\)</span>. On introduit les nominaux respectifs de chaque jambe <span class="math inline">\((N_i)_{i=1,...,m}\)</span> et <span class="math inline">\(( \tilde{N})_{j=1,...,n}\)</span> ainsi que les taux fixes <span class="math inline">\((K_i)_{i=1,...,m}\)</span> et les spreads <span class="math inline">\((s_i)_{i=1,...,m}\)</span>.</p>
<p>A la date de pricing t = 0, le prix du swap est donnée par:</p>
<p>$$</p>
<p><span class="math display">\[\begin{equation}

S_0(T_0, T) = \frac{\sum_j^n \tilde{N}_j(\tilde{t}_j - \tilde{t}_{j-1})(L(\tilde{t}_{j-1}, \tilde{t}_j) + s_j)B(0, \tilde{t}_j)}{\sum_i^m N_i(t_i-t_{i-1})B(0,t_i)}

\end{equation}\]</span></p>
<p>$$</p></li>
</ul></li>
<li><p>Rappelons le principe du bootstrapping et son importance.</p>
<p>Le principe de base du bootstrapping est de restituer - à partir de l’information disponible sur le marché - une courbe de taux zéro-coupon</p>
<p>discrète à l’aide d’une approche récursive.</p>
<p>Cette méthode est essentielle car il n’existe pas sur le marché un continuum de cotations d’obligations zéro-coupon; ceci rend impossible l’obtention directe des taux zéro-coupon pour toutes les maturités. Le bootstraping constitue donc un outil indispensable pour la construction de la courbe des taux zéro-coupon par terme, qui est la brique fondamentale pour la valorisation des instruments financiers.</p></li>
<li><p>Rappelons la différence entre une opération forward et future.</p>
<p>La différence entre un <strong>contrat forward</strong> et un <strong>contrat future</strong> réside principalement dans leur mode de négociation et de règlement. Un forward est un contrat <strong>de gré à gré</strong>, réglé en un <strong>unique paiement à l’échéance</strong>, correspondant à la différence entre le taux négocié et le taux de marché réalisé. À l’inverse, un future est <strong>standardisé et négocié sur un marché réglementé</strong>, avec un ajustement <strong>quotidien</strong> de sa valeur via des <strong>appels de marge</strong> (mark-to-market), répartissant ainsi les gains et pertes tout au long de la durée du contrat.</p></li>
</ol>
<hr>
<hr>
</section>
<section id="construction-de-la-courbe-des-taux-zéro-coupon" class="level2">
<h2 class="anchored" data-anchor-id="construction-de-la-courbe-des-taux-zéro-coupon">Construction de la courbe des taux zéro-coupon</h2>
<hr>
<ol type="1">
<li><p>L’interpolation des taux de swap pour obtenir des cotations annuelles simplifie la méthode du bootstrap en fournissant une courbe de taux continue pour toutes les maturités. Cela aligne les échéances des instruments de marché avec celles utilisées dans la construction de la courbe zéro-coupon, évitant ainsi de gérer des échéances intermédiaires ou irrégulières. Avec des intervalles de temps constants égaux à 1 an, les calculs deviennent plus simples et plus directs, permettant une extraction précise des taux zéro-coupon à chaque étape.</p></li>
<li><p>Construisons sur le segment des SWAP une nouvelle courbe de taux de marché avec des cotations annuelles obtenues à l’aide d’une méthode d’interpolation par spline.</p></li>
</ol>
<div id="495ea731" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import data</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_excel(<span class="st">"Data.xlsx"</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>df.columns <span class="op">=</span> [<span class="st">"Market"</span>, <span class="st">"MAT"</span>, <span class="st">"MKT"</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>df.head()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Market</th>
<th data-quarto-table-cell-role="th">MAT</th>
<th data-quarto-table-cell-role="th">MKT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>MM</td>
<td>0.25</td>
<td>0.030698</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>MM</td>
<td>0.50</td>
<td>0.026191</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>MM</td>
<td>0.75</td>
<td>0.023958</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>MM</td>
<td>1.00</td>
<td>0.022979</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">4</th>
<td>FUT</td>
<td>1.25</td>
<td>0.978691</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="535c4ffc" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interpolation_spline_swap(df):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    df_swap <span class="op">=</span> df[df[<span class="st">"Market"</span>] <span class="op">==</span> <span class="st">'SWAP'</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Appliquons une interpolation spline cubique</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    cs <span class="op">=</span> CubicSpline(df_swap[<span class="st">'MAT'</span>].values, df_swap[<span class="st">'MKT'</span>].values)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># générons les points pour l'affichage de la courbe </span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    maturities_gen <span class="op">=</span> np.linspace(<span class="bu">min</span>(df_swap[<span class="st">'MAT'</span>].values), <span class="bu">max</span>(df_swap[<span class="st">'MAT'</span>].values), <span class="dv">100</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    swap_rate_gen <span class="op">=</span> cs(maturities_gen)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    data_gen <span class="op">=</span> {</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Market"</span>: [<span class="st">'SWAP'</span>] <span class="op">*</span> <span class="bu">len</span>(maturities_gen),</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">'MAT'</span>: maturities_gen.tolist(),</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="st">'MKT'</span>: swap_rate_gen.tolist()</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    data_gen <span class="op">=</span> pd.DataFrame(data_gen)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data_gen</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="4d67c114" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>data_swap <span class="op">=</span>  interpolation_spline_swap(df)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>plt.plot(data_swap[<span class="st">'MAT'</span>].values,data_swap[<span class="st">'MKT'</span>].values, label <span class="op">=</span><span class="st">"Coutbe de taux swap interpolés"</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>plt.scatter(df[df[<span class="st">"Market"</span>]<span class="op">==</span> <span class="st">"SWAP"</span>][<span class="st">'MAT'</span>].values,df[df[<span class="st">"Market"</span>]<span class="op">==</span> <span class="st">"SWAP"</span>][<span class="st">'MKT'</span>].values,color <span class="op">=</span> <span class="st">"red"</span>, label <span class="op">=</span> <span class="st">"Taux swap"</span>, zorder <span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Courbe des taux swap de marché avec interpolation cubique"</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Maturité (années)"</span>)  <span class="co"># Axe des abscisses</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Taux (%)"</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-5-output-1.png" width="606" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Dans la suite, on supposera que pour ce segment, cette nouvelle courbe est la courbe de marché de référence</strong></p>
<hr>
<ol start="3" type="1">
<li><p>Calculons à présent les taux zéro-coupon continus associés à toutes les maturités de marché.</p>
<p>En appliquant le principe de bootstrap, les expressions énoncées en (1), (2), (3) , nous permettent d’obtenir de manière recursive les prix d’obligations zero coupons pour differentes maturités à partir des taux de marché.</p>
<p>Des prix de ces obligations zéro-coupons, on déduit le taux zéro-coupon par le calcul suivant :</p>
<p>$$</p>
<p>B(0, T) = (-R(0,T) T) R(0,T) = -</p>
<p>$$</p></li>
</ol>
<div id="3eb114c0" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bootstrap_yield_curve(df):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Bootstrap a yield curve from market data using cubic spline interpolation.</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">        df (pd.DataFrame): Market data with columns ["Market", "MAT", "MKT"].</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co">        pd.DataFrame: Yield curve with zero-coupon rates.</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert DataFrame into dictionary for faster lookup</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {market: df[df[<span class="st">"Market"</span>] <span class="op">==</span> market].reset_index(drop<span class="op">=</span><span class="va">True</span>) <span class="cf">for</span> market <span class="kw">in</span> [<span class="st">"MM"</span>, <span class="st">"FUT"</span>, <span class="st">"SWAP"</span>]}</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Interpolate Swap Rates</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    swap_data <span class="op">=</span> data[<span class="st">"SWAP"</span>]</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    spline <span class="op">=</span> CubicSpline(swap_data[<span class="st">"MAT"</span>], swap_data[<span class="st">"MKT"</span>])</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    maturities_annual <span class="op">=</span> np.arange(<span class="dv">3</span>, <span class="dv">31</span>, <span class="dv">1</span>)</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    interpolated_rates <span class="op">=</span> spline(maturities_annual)</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine interpolated data</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    SWAP_interpolated <span class="op">=</span> pd.DataFrame({<span class="st">"Market"</span>: <span class="st">"SWAP"</span>, <span class="st">"MAT"</span>: maturities_annual, <span class="st">"MKT"</span>: interpolated_rates})</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    df_new <span class="op">=</span> pd.concat([df[df[<span class="st">"Market"</span>] <span class="op">!=</span> <span class="st">"SWAP"</span>], SWAP_interpolated])</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update data dictionary</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"MM"</span>] <span class="op">=</span> df_new[df_new[<span class="st">"Market"</span>] <span class="op">==</span> <span class="st">"MM"</span>].reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"FUT"</span>] <span class="op">=</span> df_new[df_new[<span class="st">"Market"</span>] <span class="op">==</span> <span class="st">"FUT"</span>].reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"SWAP"</span>] <span class="op">=</span> df_new[df_new[<span class="st">"Market"</span>] <span class="op">==</span> <span class="st">"SWAP"</span>].reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Compute Zero-Coupon Rates for MM</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"MM"</span>][<span class="st">"B(0,MAT)"</span>] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> data[<span class="st">"MM"</span>][<span class="st">"MAT"</span>] <span class="op">*</span> data[<span class="st">"MM"</span>][<span class="st">"MKT"</span>])</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"MM"</span>][<span class="st">"tx ZC"</span>] <span class="op">=</span> <span class="op">-</span>np.log(data[<span class="st">"MM"</span>][<span class="st">"B(0,MAT)"</span>]) <span class="op">/</span> data[<span class="st">"MM"</span>][<span class="st">"MAT"</span>]</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Compute Zero-Coupon Rates for Futures</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"FUT"</span>][<span class="st">"B(0,MAT)"</span>] <span class="op">=</span> data[<span class="st">"MM"</span>][<span class="st">"B(0,MAT)"</span>].iloc[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>    B_tau_i <span class="op">=</span> data[<span class="st">"FUT"</span>].iloc[<span class="dv">0</span>][<span class="st">"B(0,MAT)"</span>]</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>    tau_i <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, row <span class="kw">in</span> data[<span class="st">"FUT"</span>].iterrows():</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>        T_i, f_i <span class="op">=</span> row[<span class="st">"MAT"</span>], row[<span class="st">"MKT"</span>]</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>        B_tau_i <span class="op">/=</span> (<span class="dv">1</span> <span class="op">+</span> (T_i <span class="op">-</span> tau_i) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> f_i))</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>        data[<span class="st">"FUT"</span>].at[i, <span class="st">"B(0,MAT)"</span>] <span class="op">=</span> B_tau_i</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>        tau_i <span class="op">=</span> T_i</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"FUT"</span>][<span class="st">"tx ZC"</span>] <span class="op">=</span> <span class="op">-</span>np.log(data[<span class="st">"FUT"</span>][<span class="st">"B(0,MAT)"</span>]) <span class="op">/</span> data[<span class="st">"FUT"</span>][<span class="st">"MAT"</span>]</span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 4: Compute Zero-Coupon Rates for Swaps</span></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>    B_T_1 <span class="op">=</span> data[<span class="st">"MM"</span>].loc[data[<span class="st">"MM"</span>][<span class="st">"MAT"</span>] <span class="op">==</span> <span class="dv">1</span>, <span class="st">"B(0,MAT)"</span>].values[<span class="dv">0</span>]</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>    B_T_2 <span class="op">=</span> data[<span class="st">"FUT"</span>].loc[data[<span class="st">"FUT"</span>][<span class="st">"MAT"</span>] <span class="op">==</span> <span class="dv">2</span>, <span class="st">"B(0,MAT)"</span>].values[<span class="dv">0</span>]</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> B_T_1 <span class="op">+</span> B_T_2</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"SWAP"</span>][<span class="st">"B(0,MAT)"</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> data[<span class="st">"SWAP"</span>][<span class="st">"MKT"</span>].iloc[<span class="dv">0</span>] <span class="op">*</span> A) <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> data[<span class="st">"SWAP"</span>][<span class="st">"MKT"</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(data[<span class="st">"SWAP"</span>])):</span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>        A <span class="op">+=</span> data[<span class="st">"SWAP"</span>].iloc[i <span class="op">-</span> <span class="dv">1</span>][<span class="st">"B(0,MAT)"</span>]</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a>        data[<span class="st">"SWAP"</span>].at[i, <span class="st">"B(0,MAT)"</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> data[<span class="st">"SWAP"</span>].iloc[i][<span class="st">"MKT"</span>] <span class="op">*</span> A) <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> data[<span class="st">"SWAP"</span>].iloc[i][<span class="st">"MKT"</span>])</span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">"SWAP"</span>][<span class="st">"tx ZC"</span>] <span class="op">=</span> <span class="op">-</span>np.log(data[<span class="st">"SWAP"</span>][<span class="st">"B(0,MAT)"</span>]) <span class="op">/</span> data[<span class="st">"SWAP"</span>][<span class="st">"MAT"</span>]</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine results</span></span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a>    yield_curve <span class="op">=</span> pd.concat(data.values())</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> yield_curve</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<hr>
<p>L’application de la méthode de Bootstrapping à la courbe de marché permet d’obtenir les taux zéro-coupons ci-après présentés.</p>
<div id="e19e0081" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Application du bootstraping</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>yield_zc <span class="op">=</span> bootstrap_yield_curve(df)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>yield_zc</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Market</th>
<th data-quarto-table-cell-role="th">MAT</th>
<th data-quarto-table-cell-role="th">MKT</th>
<th data-quarto-table-cell-role="th">B(0,MAT)</th>
<th data-quarto-table-cell-role="th">tx ZC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>MM</td>
<td>0.25</td>
<td>0.030698</td>
<td>0.992384</td>
<td>0.030581</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>MM</td>
<td>0.50</td>
<td>0.026191</td>
<td>0.987074</td>
<td>0.026021</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>MM</td>
<td>0.75</td>
<td>0.023958</td>
<td>0.982349</td>
<td>0.023745</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>MM</td>
<td>1.00</td>
<td>0.022979</td>
<td>0.977537</td>
<td>0.022719</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">0</th>
<td>FUT</td>
<td>1.25</td>
<td>0.978691</td>
<td>0.972357</td>
<td>0.022426</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">1</th>
<td>FUT</td>
<td>1.50</td>
<td>0.977094</td>
<td>0.966821</td>
<td>0.022495</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">2</th>
<td>FUT</td>
<td>1.75</td>
<td>0.974981</td>
<td>0.960811</td>
<td>0.022844</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">3</th>
<td>FUT</td>
<td>2.00</td>
<td>0.972911</td>
<td>0.954348</td>
<td>0.023363</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">4</th>
<td>FUT</td>
<td>2.25</td>
<td>0.970984</td>
<td>0.947475</td>
<td>0.023980</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">5</th>
<td>FUT</td>
<td>2.50</td>
<td>0.969711</td>
<td>0.940355</td>
<td>0.024599</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">6</th>
<td>FUT</td>
<td>2.75</td>
<td>0.968436</td>
<td>0.932992</td>
<td>0.025221</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">0</th>
<td>SWAP</td>
<td>3.00</td>
<td>0.026112</td>
<td>0.925392</td>
<td>0.025846</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">1</th>
<td>SWAP</td>
<td>4.00</td>
<td>0.028117</td>
<td>0.894510</td>
<td>0.027870</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">2</th>
<td>SWAP</td>
<td>5.00</td>
<td>0.029680</td>
<td>0.863031</td>
<td>0.029461</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">3</th>
<td>SWAP</td>
<td>6.00</td>
<td>0.031107</td>
<td>0.830611</td>
<td>0.030932</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">4</th>
<td>SWAP</td>
<td>7.00</td>
<td>0.032313</td>
<td>0.798250</td>
<td>0.032190</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">5</th>
<td>SWAP</td>
<td>8.00</td>
<td>0.033382</td>
<td>0.766005</td>
<td>0.033321</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">6</th>
<td>SWAP</td>
<td>9.00</td>
<td>0.034385</td>
<td>0.733744</td>
<td>0.034400</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">7</th>
<td>SWAP</td>
<td>10.00</td>
<td>0.035312</td>
<td>0.701779</td>
<td>0.035414</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">8</th>
<td>SWAP</td>
<td>11.00</td>
<td>0.036197</td>
<td>0.670056</td>
<td>0.036399</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">9</th>
<td>SWAP</td>
<td>12.00</td>
<td>0.037003</td>
<td>0.639058</td>
<td>0.037313</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">10</th>
<td>SWAP</td>
<td>13.00</td>
<td>0.037668</td>
<td>0.609615</td>
<td>0.038071</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">11</th>
<td>SWAP</td>
<td>14.00</td>
<td>0.038201</td>
<td>0.581859</td>
<td>0.038681</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">12</th>
<td>SWAP</td>
<td>15.00</td>
<td>0.038624</td>
<td>0.555759</td>
<td>0.039161</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">13</th>
<td>SWAP</td>
<td>16.00</td>
<td>0.038950</td>
<td>0.531317</td>
<td>0.039525</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">14</th>
<td>SWAP</td>
<td>17.00</td>
<td>0.039184</td>
<td>0.508571</td>
<td>0.039774</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">15</th>
<td>SWAP</td>
<td>18.00</td>
<td>0.039331</td>
<td>0.487555</td>
<td>0.039908</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">16</th>
<td>SWAP</td>
<td>19.00</td>
<td>0.039395</td>
<td>0.468277</td>
<td>0.039931</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">17</th>
<td>SWAP</td>
<td>20.00</td>
<td>0.039380</td>
<td>0.450732</td>
<td>0.039844</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">18</th>
<td>SWAP</td>
<td>21.00</td>
<td>0.039292</td>
<td>0.434869</td>
<td>0.039653</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">19</th>
<td>SWAP</td>
<td>22.00</td>
<td>0.039145</td>
<td>0.420521</td>
<td>0.039376</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">20</th>
<td>SWAP</td>
<td>23.00</td>
<td>0.038954</td>
<td>0.407474</td>
<td>0.039034</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">21</th>
<td>SWAP</td>
<td>24.00</td>
<td>0.038734</td>
<td>0.395495</td>
<td>0.038651</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">22</th>
<td>SWAP</td>
<td>25.00</td>
<td>0.038501</td>
<td>0.384336</td>
<td>0.038250</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">23</th>
<td>SWAP</td>
<td>26.00</td>
<td>0.038270</td>
<td>0.373731</td>
<td>0.037855</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">24</th>
<td>SWAP</td>
<td>27.00</td>
<td>0.038056</td>
<td>0.363408</td>
<td>0.037490</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">25</th>
<td>SWAP</td>
<td>28.00</td>
<td>0.037874</td>
<td>0.353080</td>
<td>0.037181</td>
</tr>
<tr class="even">
<th data-quarto-table-cell-role="th">26</th>
<td>SWAP</td>
<td>29.00</td>
<td>0.037739</td>
<td>0.342452</td>
<td>0.036952</td>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">27</th>
<td>SWAP</td>
<td>30.00</td>
<td>0.037668</td>
<td>0.331225</td>
<td>0.036832</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="0bff4dc1" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fonction pour appliquer le stripping</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zc_interpolation(yield_curve):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcule les taux forward 3M à partir des taux zéro-coupon.</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">    yield_curve (pd.DataFrame): Contient 'MAT' (maturité) et 'B(0,MAT)' (Prix ZC).</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co">    pd.DataFrame: Contenant 'MAT' et 'Forward 3M'.</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convertir les maturités en mois</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    yield_curve[<span class="st">"MAT_months"</span>] <span class="op">=</span> yield_curve[<span class="st">"MAT"</span>] <span class="op">*</span> <span class="dv">12</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sélection des maturités tous les 3 mois</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    maturities <span class="op">=</span> np.arange(<span class="dv">3</span>, <span class="bu">max</span>(yield_curve[<span class="st">"MAT_months"</span>]), <span class="dv">3</span>) <span class="op">/</span> <span class="dv">12</span>  <span class="co"># en années</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolation log-linéaire sur B(0,T) pour estimer tx ZC pour ces maturités</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    temp <span class="op">=</span> interp1d(yield_curve[<span class="st">"MAT"</span>], np.log(yield_curve[<span class="st">"B(0,MAT)"</span>]), kind<span class="op">=</span><span class="st">"linear"</span>, fill_value<span class="op">=</span><span class="st">"extrapolate"</span>)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    log_interp_zc <span class="op">=</span> <span class="op">-</span>np.log(temp(maturities)) <span class="op">/</span> maturities</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolation linéaire sur les tx ZC </span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>    temp <span class="op">=</span> interp1d(yield_curve[<span class="st">"MAT"</span>], yield_curve[<span class="st">"tx ZC"</span>], kind<span class="op">=</span><span class="st">"linear"</span>, fill_value<span class="op">=</span><span class="st">"extrapolate"</span>)</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>    lin_interp_zc <span class="op">=</span> temp(maturities)</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolation cubic des tx ZC pour estimer B(0,T) pour ces maturités</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>    temp  <span class="op">=</span> CubicSpline(yield_curve[<span class="st">"MAT"</span>], yield_curve[<span class="st">"tx ZC"</span>])</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    spline_interp_zc <span class="op">=</span> temp(maturities)</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">"MAT"</span>: maturities,</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"Interpolation Linéaire"</span>: lin_interp_zc,</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"Interpolation log-linéaire"</span>: log_interp_zc,</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"Interpolation Spline"</span>: spline_interp_zc}</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_curve(forward_rates, columns <span class="op">=</span> [<span class="st">"Interpolation Spline"</span>, <span class="st">"Interpolation Linéaire"</span>], title<span class="op">=</span> <span class="st">"Courbe des Taux Forwards 3M"</span>):</span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a><span class="co">    Trace la courbe des taux forwards en utilisant l'interpolation linéaire et spline.</span></span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a><span class="co">    forward_rates (pd.DataFrame): Contenant 'MAT' et 'Forward 3M'.</span></span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Tracé des courbes</span></span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> columns:</span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a>        plt.plot(forward_rates[<span class="st">"MAT"</span>], forward_rates[col],  label<span class="op">=</span>col)</span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Maturité (années)"</span>)</span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Taux d'intérêt"</span>)</span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-117"><a href="#cb7-117" aria-hidden="true" tabindex="-1"></a>    plt.grid()</span>
<span id="cb7-118"><a href="#cb7-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-119"><a href="#cb7-119" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<hr>
<p><strong>Stripping</strong></p>
<p>Nous utilisons trois méthodes pour réaliser l’interpolation de la</p>
<p>courbe discrète des taux zéro-coupon obtenue via le bootstrapping précédent.</p>
<ul>
<li><p><em>Une interpolation linéaire par morceaux (taux zéro-coupon)</em>:</p>
<p>l’hypothèse est que la fonction <span class="math inline">\(R(0,T)\)</span> est linéaire entre deux maturités successives <span class="math inline">\(T_{i-1}\)</span> et $T_i $ :</p>
<p>$$</p>
<p>R(0,T) = _i(T) R(0,T_i) + (1 - <em>i(T)) R(0,T</em>{i-1}), T </p>
<p>$$</p>
<p>avec :</p>
<p>$$</p>
<p>_i(T) = </p>
<p>$$</p></li>
<li><p><em>Une interpolation log-linéaire par morceaux (prix des obligations zéro-coupon)</em>:</p>
<p>on suppose que la fonction ( B(0,T) ) est log-linéaire par morceaux</p>
<p>$$</p>
<pre><code>  R(0,T) \cdot T = \lambda_i(T) R(0,T_i) T_i + (1 - \lambda_i(T)) R(0,T_{i-1}) T_{i-1}, \quad \text{pour } T \in [T_{i-1}, T_i]</code></pre>
<p>$$</p>
<p>où <span class="math inline">\(\lambda_i(T)\)</span> est défini comme précédemment.</p></li>
<li><p><em>Une interpolation par spline cubique</em></p></li>
</ul>
<p>Pour ces trois méthodes, la courbe de taux interpolée a le même allure comme illustrée ci-après.</p>
<div id="f811b267" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Application du stripping</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>courbe_zc <span class="op">=</span> pd.DataFrame(zc_interpolation(yield_zc))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Tracé des courbes interpolées</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>plot_curve(courbe_zc,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>           columns <span class="op">=</span> [<span class="st">"Interpolation Spline"</span>, <span class="st">"Interpolation Linéaire"</span>,<span class="st">"Interpolation log-linéaire"</span>],</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>           title<span class="op">=</span> <span class="st">"Courbe de taux Zero-coupon"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\679077462.py:45: RuntimeWarning: invalid value encountered in log
  log_interp_zc = -np.log(temp(maturities)) / maturities</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-9-output-2.png" width="837" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<ol start="4" type="1">
<li><p>Le mode d’interpolation des taux zéro-coupon a un impact direct sur le calcul des taux de marché, car il conditionne <strong>la forme</strong> et <strong>la régularité</strong> de la courbe des taux. En particulier, les méthodes d’interpolation linéaires et log-linéaires génèrent de fortes irrégularités sur la courbe des taux forward implicite.</p>
<p>Ceci peut s’expliquer par le fait que l’information de marché est très dispersée sur la partie swap. Ceci étant principalement dû à l’espacement important entre les maturités des taux swap consécutifs observés, qui s’étend sur une année dans notre cas. Ainsi, ces deux méthodes d’interpolation standards sont</p>
<p>souvent inadaptées en terme de lissage des courbes implicites.</p></li>
</ol>
<hr>
</section>
<section id="construction-de-la-courbe-des-taux-forward" class="level2">
<h2 class="anchored" data-anchor-id="construction-de-la-courbe-des-taux-forward">Construction de la courbe des taux forward</h2>
<hr>
<ol type="1">
<li>À partir de la courbe des taux zéro-coupon obtenue par bootstrapping, traçons la courbe des taux forwards 3Mois en fonction de la maturité en utilisant les differentes méthodes d’interpolation présentées précédemment.</li>
</ol>
<p>Le graphique ci après présente les courbes de taux forward 3 mois obtenue en fonction des différentes méthodes d’interpolation.</p>
<div id="b5b423e2" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Courbe des taux forward de tenor 3 mois</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_forward_rates(yield_curve):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcule les taux forward 3M à partir des taux zéro-coupon.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co">    yield_curve (pd.DataFrame): Contient 'MAT' (maturité) et 'B(0,MAT)' (Prix ZC).</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="co">    pd.DataFrame: Contenant 'MAT' et 'Forward 3M'.</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convertir les maturités en mois</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    yield_curve[<span class="st">"MAT_months"</span>] <span class="op">=</span> yield_curve[<span class="st">"MAT"</span>] <span class="op">*</span> <span class="dv">12</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sélection des maturités tous les 3 mois</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    maturities <span class="op">=</span> np.arange(<span class="dv">3</span>, <span class="bu">max</span>(yield_curve[<span class="st">"MAT_months"</span>]), <span class="dv">3</span>) <span class="op">/</span> <span class="dv">12</span>  <span class="co"># en années</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolation log-linéaire sur B(0,T) pour estimer B(0,T) pour ces maturités</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    log_interp_bond_prices <span class="op">=</span> interp1d(yield_curve[<span class="st">"MAT"</span>], np.log(yield_curve[<span class="st">"B(0,MAT)"</span>]), kind<span class="op">=</span><span class="st">"linear"</span>, fill_value<span class="op">=</span><span class="st">"extrapolate"</span>)</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul des prix interpolés</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>    B_t <span class="op">=</span> np.exp(log_interp_bond_prices(maturities))</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>    B_t_3M <span class="op">=</span> np.exp(log_interp_bond_prices(maturities <span class="op">+</span> <span class="fl">0.25</span>))  <span class="co"># 3 mois plus tard</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward 3M</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>    forward_rates_log <span class="op">=</span> ((B_t <span class="op">/</span> B_t_3M) <span class="op">-</span> <span class="dv">1</span>)<span class="op">/</span><span class="fl">0.25</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolation linéaire sur les tx ZC pour estimer B(0,T) pour ces maturités</span></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>    lin_interp_bond_prices <span class="op">=</span> interp1d(yield_curve[<span class="st">"MAT"</span>], yield_curve[<span class="st">"tx ZC"</span>], kind<span class="op">=</span><span class="st">"linear"</span>, fill_value<span class="op">=</span><span class="st">"extrapolate"</span>)</span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul des prix interpolés</span></span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>    B_t <span class="op">=</span> np.exp(<span class="op">-</span>lin_interp_bond_prices(maturities)<span class="op">*</span>maturities)</span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>    B_t_3M <span class="op">=</span> np.exp(<span class="op">-</span>lin_interp_bond_prices(maturities <span class="op">+</span> <span class="fl">0.25</span>)<span class="op">*</span>(maturities <span class="op">+</span> <span class="fl">0.25</span>))  <span class="co"># 3 mois plus tard</span></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward 3M</span></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>    forward_rates_lin <span class="op">=</span> ((B_t <span class="op">/</span> B_t_3M) <span class="op">-</span> <span class="dv">1</span>)<span class="op">/</span><span class="fl">0.25</span></span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolation cubic des tx ZC pour estimer B(0,T) pour ces maturités</span></span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a>    spline_interp_bond_prices <span class="op">=</span> CubicSpline(yield_curve[<span class="st">"MAT"</span>], yield_curve[<span class="st">"tx ZC"</span>])</span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul des prix interpolés</span></span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true" tabindex="-1"></a>    B_t <span class="op">=</span> np.exp(<span class="op">-</span>spline_interp_bond_prices(maturities)<span class="op">*</span>maturities)</span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true" tabindex="-1"></a>    B_t_3M <span class="op">=</span> np.exp(<span class="op">-</span>spline_interp_bond_prices(maturities <span class="op">+</span> <span class="fl">0.25</span>)<span class="op">*</span>(maturities <span class="op">+</span> <span class="fl">0.25</span>))  <span class="co"># 3 mois plus tard</span></span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-98"><a href="#cb11-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-99"><a href="#cb11-99" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward 3M</span></span>
<span id="cb11-100"><a href="#cb11-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-101"><a href="#cb11-101" aria-hidden="true" tabindex="-1"></a>    forward_rates_spline <span class="op">=</span> ((B_t <span class="op">/</span> B_t_3M) <span class="op">-</span> <span class="dv">1</span>)<span class="op">/</span><span class="fl">0.25</span></span>
<span id="cb11-102"><a href="#cb11-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-103"><a href="#cb11-103" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-104"><a href="#cb11-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-105"><a href="#cb11-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">"MAT"</span>: maturities,</span>
<span id="cb11-106"><a href="#cb11-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-107"><a href="#cb11-107" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"Interpolation Linéaire"</span>: forward_rates_lin,</span>
<span id="cb11-108"><a href="#cb11-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-109"><a href="#cb11-109" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"Interpolation log-linéaire"</span>: forward_rates_log,</span>
<span id="cb11-110"><a href="#cb11-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-111"><a href="#cb11-111" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"Interpolation Spline"</span>: forward_rates_spline}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="851ce416" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcul de la courbe des taux forwards</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>forward_rates <span class="op">=</span> pd.DataFrame(compute_forward_rates(yield_zc))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Tracé des courbes interpolées</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>plot_curve(forward_rates, columns <span class="op">=</span> [<span class="st">"Interpolation Spline"</span>, <span class="st">"Interpolation Linéaire"</span>,<span class="st">"Interpolation log-linéaire"</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-11-output-1.png" width="829" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<p>On constate des irrégularités pour les interpolations linéaires et log-linéaires, contrairement à la courbe obtenue via une interpolation spline qui est plus lisse.</p>
<p>Les irrégularités observées pour les interpolations linéaires et log-linéaires sont observés à partir de la maturité 3 ans. Ceci est cohérent avec l’analyse faite plus haut. En effet, à partir de cette maturité, les taux zero coupons ont été extraits à partir de taux swap de marché.</p>
<ol start="2" type="1">
<li>Shiftons le taux de swap 5Y de 10 bps, puis expliquons l’impact sur les courbes des taux zéro-coupon et forward.</li>
</ol>
<div id="eff6802e" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1bp = 0.01% donc 10bps = 0.10%=0.0001</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>df_bumped <span class="op">=</span> yield_zc.copy()</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>df_bumped.loc[df_bumped[<span class="st">"MAT"</span>]<span class="op">==</span><span class="dv">5</span>,<span class="st">"MKT"</span>] <span class="op">=</span> df_bumped.loc[df_bumped[<span class="st">"MAT"</span>]<span class="op">==</span><span class="dv">5</span>,<span class="st">"MKT"</span>] <span class="op">+</span> <span class="fl">0.001</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>yield_bumped <span class="op">=</span> bootstrap_yield_curve(df_bumped) <span class="co"># On refait le bootstraping</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Application du stripping</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>courbe_zc_bump <span class="op">=</span> pd.DataFrame(zc_interpolation(yield_bumped))</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Tracé des courbes interpolées</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>plot_curve(courbe_zc_bump,</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>           columns <span class="op">=</span> [<span class="st">"Interpolation Spline"</span>, <span class="st">"Interpolation Linéaire"</span>,<span class="st">"Interpolation log-linéaire"</span>],</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>           title<span class="op">=</span> <span class="st">"Courbe de taux Zero-coupon shiftée"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\679077462.py:45: RuntimeWarning: invalid value encountered in log
  log_interp_zc = -np.log(temp(maturities)) / maturities</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-12-output-2.png" width="837" height="524" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="b1f23295" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcul de la courbe des taux forwards</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>forward_rates_bumped <span class="op">=</span> pd.DataFrame(compute_forward_rates(yield_bumped))</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>forward_rates_bumped.rename(columns<span class="op">=</span>{<span class="st">"Interpolation Linéaire"</span>: <span class="st">"Interpolation Linéaire shift"</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">"Interpolation log-linéaire"</span>: <span class="st">"Interpolation log-linéaire shift"</span>,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">"Interpolation Spline"</span>: <span class="st">"Interpolation Spline shift"</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>forward_rates_bumped <span class="op">=</span> forward_rates_bumped.merge(forward_rates, on<span class="op">=</span><span class="st">"MAT"</span>, how<span class="op">=</span><span class="st">"inner"</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Tracé des courbes interpolées</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>plot_curve(forward_rates_bumped,</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>           columns<span class="op">=</span>[<span class="st">"Interpolation Spline"</span>, <span class="st">"Interpolation Spline shift"</span>],</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>           title<span class="op">=</span><span class="st">"Courbe des Taux Forwards 3M shiftée"</span>)  <span class="co"># On passe l'axe correspondant</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>plot_curve(forward_rates_bumped,</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>           columns<span class="op">=</span>[<span class="st">"Interpolation Linéaire"</span>, <span class="st">"Interpolation Linéaire shift"</span>],</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>           title<span class="op">=</span><span class="st">"Courbe des Taux Forwards 3M shiftée"</span>)  </span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>plot_curve(forward_rates_bumped,</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>           columns<span class="op">=</span>[<span class="st">"Interpolation log-linéaire"</span>, <span class="st">"Interpolation log-linéaire shift"</span>],</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>           title<span class="op">=</span><span class="st">"Courbe des Taux Forwards 3M shiftée"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-13-output-1.png" width="829" height="523" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-13-output-2.png" width="829" height="523" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-13-output-3.png" width="829" height="523" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>On observe que le shift de 10 bps sur le taux swap 5Y entraîne une modification des courbes de taux forward 3 mois, avec des effets qui varient selon la méthode d’interpolation utilisée.</p>
<p>Cette différence de comportement découle des propriétés des méthodes d’interpolation utilisées. L’interpolation <strong>linéaire</strong> et <strong>log-linéaire</strong> segmente l’évolution des taux entre deux maturités successives <span class="math inline">\(T_{i-1}\)</span> et $ T_i$ , en supposant une variation <strong>linéaire</strong> des taux zero coupons sur chaque intervalle. Ainsi, lorsqu’un <strong>bump</strong> est appliqué, son impact reste <strong>localisé</strong>, et les taux forward reviennent rapidement à leur trajectoire initiale.</p>
<p>À l’inverse, l’interpolation <strong>spline</strong> assure une transition plus <strong>fluide</strong> en imposant des contraintes de <strong>régularité</strong> sur la dérivée seconde. Cette régularité propage l’effet du <strong>bump</strong> de manière plus <strong>progressive</strong>, entraînant une déviation plus <strong>large</strong> et plus <strong>persistante</strong> des taux forward.</p>
<hr>
<hr>
</section>
</section>
<section id="valorisation-de-swaptions-et-de-caplets" class="level1">
<h1>Valorisation de swaptions et de caplets</h1>
<hr>
<ol type="1">
<li><p>Les caplets et floorlets, qui sont des options sur taux d’intérêt à court terme, sont généralement valorisés à l’aide du .</p></li>
<li><p>Rappelons les EDS des taux forwards, des taux de swap forward ainsi que les probabilités associées. </p></li>
<li><p>Rappelons les formules de valorisation des oplets et swaptions.</p>
<p>Un <strong>caplet</strong> (resp. floorlet) est une option d’achat (resp. de vente) sur un taux Libor. En</p>
<p>notant <span class="math inline">\(T_{i-1}\)</span> la date d’échéance de l’option, et <span class="math inline">\(T_i\)</span> la date de paiement fixé à la date, dans le modèle de Black, sa valorisation est donnée par :</p>
<p><span class="math display">\[\text{Caplet}(t, T_{i-1}, T_i) = N \delta_i B(t,T_i) \left[ L_i(t) \Phi(d_1) - K \Phi(d_2) \right]\]</span></p>
<p><span class="math display">\[\text{Floorlet}(t, T_{i-1}, T_i) = N \delta_i B(t,T_i) \left[ K \Phi(-d_2) - L_i(t) \Phi(-d_1) \right]\]</span></p>
<p>avec :</p>
<p>$$d_1 = , </p>
<p>d_2 = d_1 - _i $$</p></li>
</ol>
<ul>
<li><p>$N $ est le nominal,</p></li>
<li><p><span class="math inline">\(\delta_i = T_i - T_{i-1}\)</span> est le facteur de période associé au taux Libor,</p></li>
<li><p><span class="math inline">\(B(t,T_i)\)</span> est le prix du zéro-coupon à maturité <span class="math inline">\(T_i\)</span> ,</p></li>
<li><p><span class="math inline">\(L_i(t)\)</span> est le taux forward observé à <span class="math inline">\(t\)</span> pour la période <span class="math inline">\([T_{i-1}, T_i]\)</span>,</p></li>
<li><p><span class="math inline">\(K\)</span> est le taux d’exercice (strike),</p></li>
<li><p><span class="math inline">\(\sigma_i\)</span> est la volatilité implicite du taux forward <span class="math inline">\(L_i\)</span>,</p></li>
<li><p><span class="math inline">\(\Phi\)</span> est la fonction de répartition de la loi normale standard.</p>
<p>Une <strong>swaption</strong> est une option d’entrée dans un swap à une date future $T_0 $. Le prix d’une swaption <span class="math inline">\(payeuse\)</span> s’écrit :</p>
<p><span class="math inline">\(\text{Swaption}(t) = N \sum_{j=1}^{n} B(t,T_j) \left[ F_S(t) \Phi(d_1) - K \Phi(d_2) \right]\)</span></p>
<p>et celui d’une swaption :</p>
<p><span class="math inline">\(\text{Swaption}(t) = N \sum_{j=1}^{n} B(t,T_j) \left[ K \Phi(-d_2) - F_S(t) \Phi(-d_1) \right]\)</span></p>
<p>avec :</p>
<p><span class="math display">\[d_1 = \frac{\ln\left( \frac{F_S(t)}{K} \right) + \frac{1}{2} \sigma^2 (T_0 - t)}{\sigma \sqrt{T_0 - t}}, \]</span></p>
<p><span class="math display">\[d_2 = d_1 - \sigma \sqrt{T_0 - t}\]</span></p>
<p>où <span class="math inline">\(F_S(t)\)</span> est le taux swap forward, <span class="math inline">\(\sigma\)</span> la volatilité implicite de la swaption.</p></li>
</ul>
<ol start="4" type="1">
<li>A partir des cotations forunies et de la courbe des taux zéro-coupon que nous avons construite précédemment, calculons les prix de marché de caplets sur euribor12M, de maturité 5Y et de strikes donnés.</li>
</ol>
<p>Les valeurs des différents paramètres servant aux calculs sont essentiellement :</p>
<ul>
<li><p>taux forward sur la période 5-6 ans est de <span class="math inline">\(3.9\%\)</span>,</p></li>
<li><p>le discount factor <span class="math inline">\((0.830)\)</span> - qui est la valeur d’une obligation zero coupon de maturité 6 ans-,</p></li>
<li><p>la <span class="math inline">\(volatilité\)</span> et le <strong>strike</strong> fournis dans l’énoncé.</p></li>
</ul>
<div id="9baa6e87" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculer_taux_forward(yield_curve, T, delta):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolation cubic des tx ZC pour estimer B(0,T) pour ces maturités</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    spline_interp_bond_prices <span class="op">=</span> CubicSpline(yield_curve[<span class="st">"MAT"</span>], yield_curve[<span class="st">"tx ZC"</span>])</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul des prix interpolés</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    B_t <span class="op">=</span> np.exp(<span class="op">-</span>spline_interp_bond_prices(T)<span class="op">*</span>T)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    B_t_delta <span class="op">=</span> np.exp(<span class="op">-</span>spline_interp_bond_prices(T <span class="op">+</span> delta)<span class="op">*</span>(T <span class="op">+</span> delta))</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward delta*12 Mois</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>  ((B_t <span class="op">/</span> B_t_delta) <span class="op">-</span> <span class="dv">1</span>)<span class="op">/</span>delta</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prix_caplet(forward, strike, volatilite, T, delta<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcule le prix d'un caplet en utilisant la formule de Black.</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="co">    :param forward: Le taux forward pour la période donnée</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a><span class="co">    :param strike: Le strike du caplet en taux relatif</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a><span class="co">    :param volatilite: La volatilité implicite du caplet</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a><span class="co">    :param T: La maturité du caplet (en années)</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a><span class="co">    :param taux_zerocoupon: Le taux zéro-coupon pour la maturité T</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Le prix du caplet</span></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul des d1 et d2 pour la formule de Black</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(forward <span class="op">/</span> strike) <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> volatilite<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> T) <span class="op">/</span> (volatilite <span class="op">*</span> np.sqrt(T))</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> volatilite <span class="op">*</span> np.sqrt(T)</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fonction de répartition normale</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>    N_d1 <span class="op">=</span> norm.cdf(d1)</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>    N_d2 <span class="op">=</span> norm.cdf(d2)</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du discount factor</span></span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>    taux_zc_T_plus_delta <span class="op">=</span> yield_zc[yield_zc[<span class="st">'MAT'</span>] <span class="op">==</span> T <span class="op">+</span> delta][<span class="st">"tx ZC"</span>].values[<span class="dv">0</span>]</span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a>    discount_factor <span class="op">=</span> np.exp(<span class="op">-</span>taux_zc_T_plus_delta <span class="op">*</span> (T<span class="op">+</span>delta))</span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prix du caplet</span></span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a>    prix <span class="op">=</span> discount_factor <span class="op">*</span> (forward <span class="op">*</span> N_d1 <span class="op">-</span> strike <span class="op">*</span> N_d2)</span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([prix, discount_factor])</span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-77"><a href="#cb16-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-78"><a href="#cb16-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-79"><a href="#cb16-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-80"><a href="#cb16-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-81"><a href="#cb16-81" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculer_prix_caplets(zero_coupons_df, strikes, volatilites, T, delta <span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb16-82"><a href="#cb16-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-83"><a href="#cb16-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb16-84"><a href="#cb16-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-85"><a href="#cb16-85" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcule les prix des caplets sur Euribor 12M à partir des données et des paramètres fournis.</span></span>
<span id="cb16-86"><a href="#cb16-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-87"><a href="#cb16-87" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb16-88"><a href="#cb16-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-89"><a href="#cb16-89" aria-hidden="true" tabindex="-1"></a><span class="co">    :param zero_coupons_df: DataFrame contenant les taux zéro-coupon et les maturités</span></span>
<span id="cb16-90"><a href="#cb16-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-91"><a href="#cb16-91" aria-hidden="true" tabindex="-1"></a><span class="co">    :param strikes: Liste des strikes en bps</span></span>
<span id="cb16-92"><a href="#cb16-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-93"><a href="#cb16-93" aria-hidden="true" tabindex="-1"></a><span class="co">    :param volatilites: Liste des volatilités implicites des caplets</span></span>
<span id="cb16-94"><a href="#cb16-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-95"><a href="#cb16-95" aria-hidden="true" tabindex="-1"></a><span class="co">    :param T: Maturité des caplets (en années)</span></span>
<span id="cb16-96"><a href="#cb16-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-97"><a href="#cb16-97" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: Une liste des prix des caplets</span></span>
<span id="cb16-98"><a href="#cb16-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-99"><a href="#cb16-99" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-100"><a href="#cb16-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-101"><a href="#cb16-101" aria-hidden="true" tabindex="-1"></a>    prix_caplets <span class="op">=</span> []</span>
<span id="cb16-102"><a href="#cb16-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-103"><a href="#cb16-103" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-104"><a href="#cb16-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-105"><a href="#cb16-105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward pour la maturité T</span></span>
<span id="cb16-106"><a href="#cb16-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-107"><a href="#cb16-107" aria-hidden="true" tabindex="-1"></a>    forward <span class="op">=</span> calculer_taux_forward(zero_coupons_df, T, delta)</span>
<span id="cb16-108"><a href="#cb16-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-109"><a href="#cb16-109" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>( <span class="st">"Taux forward :</span><span class="ch">\t</span><span class="st">"</span>, <span class="bu">round</span>(forward<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>),<span class="st">'%'</span>)</span>
<span id="cb16-110"><a href="#cb16-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-111"><a href="#cb16-111" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-112"><a href="#cb16-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-113"><a href="#cb16-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> strike, volatilite <span class="kw">in</span> <span class="bu">zip</span>(strikes, volatilites):</span>
<span id="cb16-114"><a href="#cb16-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-115"><a href="#cb16-115" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Conversion du strike de bps en taux relatif</span></span>
<span id="cb16-116"><a href="#cb16-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-117"><a href="#cb16-117" aria-hidden="true" tabindex="-1"></a>        strike_rel <span class="op">=</span> forward <span class="op">+</span> (strike <span class="op">/</span> <span class="dv">10000</span>) </span>
<span id="cb16-118"><a href="#cb16-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-119"><a href="#cb16-119" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calcul du prix du caplet pour chaque strike et volatilité</span></span>
<span id="cb16-120"><a href="#cb16-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-121"><a href="#cb16-121" aria-hidden="true" tabindex="-1"></a>        prix <span class="op">=</span> prix_caplet(forward, strike_rel, volatilite, T, delta)</span>
<span id="cb16-122"><a href="#cb16-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-123"><a href="#cb16-123" aria-hidden="true" tabindex="-1"></a>        prix_caplets.append(prix[<span class="dv">0</span>])</span>
<span id="cb16-124"><a href="#cb16-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-125"><a href="#cb16-125" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb16-126"><a href="#cb16-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-127"><a href="#cb16-127" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Discount factor: </span><span class="ch">\t</span><span class="st">"</span>, np.<span class="bu">round</span>(prix[<span class="dv">1</span>],<span class="dv">2</span>))</span>
<span id="cb16-128"><a href="#cb16-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-129"><a href="#cb16-129" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-130"><a href="#cb16-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-131"><a href="#cb16-131" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prix_caplets</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Les prix des caplets suivant differents strikes (en bps et en rel. / fwd) , et volatilités sont donnés ci après:</p>
<hr>
<div id="6248addc" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Liste des strikes en bps </span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>strikes <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">100</span>, <span class="op">-</span><span class="dv">50</span>, <span class="op">-</span><span class="dv">25</span>, <span class="dv">0</span>, <span class="dv">25</span>, <span class="dv">50</span>, <span class="dv">100</span>])</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Liste des volatilités des caplets</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>vol <span class="op">=</span> np.array([<span class="fl">31.2</span><span class="op">/</span><span class="dv">100</span>, <span class="fl">28.4</span><span class="op">/</span><span class="dv">100</span>, <span class="fl">26.6</span><span class="op">/</span><span class="dv">100</span>, <span class="fl">25.0</span><span class="op">/</span><span class="dv">100</span>, <span class="fl">24.4</span><span class="op">/</span><span class="dv">100</span>, <span class="fl">25.0</span><span class="op">/</span><span class="dv">100</span>, <span class="fl">27.2</span><span class="op">/</span><span class="dv">100</span>])</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculer les prix des caplets</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>prix_caplets <span class="op">=</span> calculer_prix_caplets(yield_zc, strikes, vol, T<span class="op">=</span><span class="dv">5</span>) <span class="co"># Maturité des caplets (5 ans)</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Préparation des données pour le tableau</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>table_data <span class="op">=</span> []</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(prix_caplets)):</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    table_data.append([strikes[i], <span class="bu">round</span>(vol[i]<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>), <span class="bu">round</span>(prix_caplets[i]<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>)])</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage des résultats dans un tableau</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>headers <span class="op">=</span> [<span class="st">"Strike (bps)"</span>, <span class="st">"Volatilité (%)"</span>, <span class="st">"Caplet MKT Price (%)"</span>]</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tabulate(table_data, headers<span class="op">=</span>headers, tablefmt<span class="op">=</span><span class="st">"pretty"</span>, floatfmt<span class="op">=</span><span class="st">".4f"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Taux forward :   3.9 %
Discount factor:     0.83
+--------------+----------------+----------------------+
| Strike (bps) | Volatilité (%) | Caplet MKT Price (%) |
+--------------+----------------+----------------------+
|     -100     |      31.2      |         1.25         |
|     -50      |      28.4      |         0.98         |
|     -25      |      26.6      |         0.84         |
|      0       |      25.0      |         0.71         |
|      25      |      24.4      |         0.62         |
|      50      |      25.0      |         0.57         |
|     100      |      27.2      |         0.52         |
+--------------+----------------+----------------------+</code></pre>
</div>
</div>
<hr>
<hr>
</section>
<section id="le-modèle-de-hullwhite" class="level1">
<h1>Le Modèle de Hull&amp;White</h1>
<hr>
<section id="du-modèle-hjm-vers-le-modèle-hullwhite" class="level2">
<h2 class="anchored" data-anchor-id="du-modèle-hjm-vers-le-modèle-hullwhite">Du modèle HJM vers le modèle Hull&amp;White</h2>
<hr>
<p>On souhaite retrouver la dynamique du taux forward instantané. Le prix du bond zéro coupon évoluant sous la probabilité risque neutre selon la dynamique:</p>
<p><span class="math display">\[\frac{dB(t,T)}{B(t,T)} = r_t dt + \Gamma(t,T)dW_t^Q\]</span></p>
<p>qui est une EDS géométrique, on vérifie par le lemme d’Îto que la solution à cette EDS est</p>
<p>$$</p>
<p>B(t,T) = B(0,T) (_0^tr_udu - _0^t ^2(u,T)du + _0^t (u,T)dW_u^Q)</p>
<p>$$ .</p>
<p>En appliquant le logarithme à cette égalité, on obtient</p>
<p>$$</p>
<p>(B(t,T)) = (B(0,T)) + _0^tr_udu - _0^t ^2(u,T)du + _0^t (u,T)dW_u^Q</p>
<p>$$</p>
<p>et</p>
<p><span class="math display">\[\begin{align*}

    f(t,T) &amp;= -\partial_T \ln(B(t,T))\\

           &amp;= -\partial_T \ln(B(0,T)) +\frac{1}{2} \int_0^t 2\Gamma(u,T)\partial_T\Gamma(u,T)du - \int_0^t \partial_T\Gamma(u,T)dW_u^Q

\end{align*}\]</span></p>
<p>Par suite</p>
<p><span class="math display">\[\begin{align*}

    df(t,T) &amp;=   \Gamma(t,T)\partial_T\Gamma(t,T) -\partial_T\Gamma(t,T)dW_t^Q\\

            &amp;= \gamma(t,T) \int_t^T \gamma(t,u)du + \gamma(t,T)dW_t^Q

\end{align*}\]</span></p>
<p>où <span class="math display">\[\gamma(t,T) = -\partial_T\Gamma(t,T).\]</span></p>
<p>Le lemme dÎto permet alors de retrouver</p>
<p>$$</p>
<p>f(t,T) = f(o,T) + _0^t (s,T) _s^T (s,u)duds + _0^t (s,T)dW_s^Q</p>
<p>$$.</p>
<hr>
</section>
<section id="hypothèses-du-modèle-hullwhite" class="level2">
<h2 class="anchored" data-anchor-id="hypothèses-du-modèle-hullwhite">Hypothèses du modèle Hull&amp;White</h2>
<hr>
<p>On suppose que le modèle HJM est gaussien, linéaire et calibrable.Ces trois hypothèses nous permettent d’écrire:</p>
<p>$$</p>
<pre><code>\begin{cases}

    \gamma(t,T) = \sigma(t)e^{-\lambda(T-t)} \\

    \Gamma(t,T) = \frac{\sigma(t)}{\lambda}(e^{-\lambda(T-t)}-1)

\end{cases}</code></pre>
<p>$$</p>
<p>où la fonction de volatilité instantanée <span class="math inline">\(\sigma(t)\)</span> est constante par morceaux.</p>
<hr>
</section>
<section id="construction-de-la-formule-zéro-coupon" class="level2">
<h2 class="anchored" data-anchor-id="construction-de-la-formule-zéro-coupon">Construction de la formule zéro-coupon</h2>
<hr>
<p>On considère le modèle de Hull&amp;White</p>
<p>$$</p>
<p>dX_t = ((t)-X_t) + (t)dW_t^Q.</p>
<p>$$</p>
<ol type="1">
<li><p>Le modèle de Hull-White fait partie de la famille des EDS à coefficients affines.</p></li>
<li><p>On veut déterminer la loi du processus <span class="math inline">\(X_t|X_s\)</span>. On commence par résoudre l’EDS à coefficients affines</p>
<p>$$</p>
<p>dX_t = ((t) - X_t)dt + (t) dW_t^Q</p>
<p>$$.</p>
<p>Posons <span class="math inline">\(Y_t = X_t e^{\lambda t}\)</span>. Alors,</p>
<p><span class="math display">\[\begin{align*}

    dY_t &amp;= \lambda e^{\lambda t} X_t dt + e^{\lambda t}dX_t\\

            &amp;= \lambda e^{\lambda t} X_t dt + e^{\lambda t} \left(

(\phi(t) - \lambda X_t)dt + \sigma(t) dW_t^Q \right)\\

            &amp;= \lambda e^{\lambda t} X_t dt + e^{\lambda t} \phi(t)dt - e^{\lambda t} \lambda X_tdt +  e^{\lambda t} \sigma(t) dW_t^Q\\

            &amp;=  e^{\lambda t} \phi(t)dt +  e^{\lambda t} \sigma(t) dW_t^Q\\

\end{align*}\]</span></p>
<p>Ainsi, par le lemme d’Îto,</p>
<p><span class="math display">\[\begin{align*}

    Y_t &amp;= Y_0 + \int_0^t e^{\lambda u} \phi(u)du +  \int_0^t e^{\lambda u} \sigma(u) dW_u^Q\\

    X_t e^{\lambda t} &amp;=  Y_0 +  \int_0^t e^{\lambda u} \phi(u)du +  \int_0^t e^{\lambda u} \sigma(u) dW_u^Q\\

    X_t  &amp;= X_0 + e^{-\lambda t} \int_0^t e^{\lambda u} \phi(u)du + e^{-\lambda t} \int_0^t e^{\lambda u} \sigma(u) dW_u^Q

\end{align*}\]</span></p>
<p>Posons</p>
<p>$$</p>
<p>M_t = _0^t e^{u} (u) dW_u^Q,</p>
<p>$$</p>
<p>pour tout <span class="math inline">\(t \geq 0\)</span>.</p>
<p>Le processus <span class="math inline">\((M_t)_{t \geq 0}\)</span> est une martingale locale comme intégralle stochastique d’une martingale locale et</p>
<p>$$</p>
<p>E([M]_t) = _0^t e^{2u} ^2(u)du &lt; +,</p>
<p>$$</p>
<p>donc <span class="math inline">\(M\)</span> est une vraie martingale.</p>
<p>Finalement, <span class="math inline">\(X_t\)</span> suit une distribution gaussienne, pour tout <span class="math inline">\(t \geq 0\)</span>.</p>
<p>On en déduit que <span class="math inline">\(X_t|X_s\)</span> suit une loi gaussienne d’espérance <span class="math inline">\(E(X_t |X_s)\)</span> et de variance <span class="math inline">\(V(X_t |X_s)\)</span>.</p>
<p>Soit <span class="math inline">\(t&gt;s \geq 0\)</span>,</p>
<p><span class="math display">\[\begin{align*}

    X_t e^{\lambda t} &amp;=  X_0 +  \int_0^s e^{\lambda u} \phi(u)du +  \int_0^s e^{\lambda u} \sigma(u) dW_u^Q + \int_s^t e^{\lambda u} \phi(u)du + \notag \\

  &amp;\quad \int_s^t e^{\lambda u} \sigma(u) dW_u^Q\\

    X_t e^{\lambda (t-s)} &amp;=  e^{-\lambda s} \left(X_0 +  \int_0^s e^{\lambda u} \phi(u)du +  \int_0^s e^{\lambda u} \sigma(u) dW_u^Q \right)+ \notag \\

  &amp;\quad e^{-\lambda s} \left(\int_s^t e^{\lambda u} \phi(u)du +  \int_s^t e^{\lambda u} \sigma(u) dW_u^Q\right)\\

    X_t e^{\lambda (t-s)} &amp;=  X_s + e^{-\lambda s} \left(\int_s^t e^{\lambda u} \phi(u)du +  \int_s^t e^{\lambda u} \sigma(u) dW_u^Q\right)\\

    X_t  &amp;=  X_se^{-\lambda (t-s)} + e^{-\lambda t} \int_s^t e^{\lambda u} \phi(u)du + e^{-\lambda t} (M_t-M_s)\\

\end{align*}\]</span></p>
<p>Il vient que</p>
<p><span class="math display">\[\begin{align*}

    E(X_t|X_s)  &amp;=  E(X_se^{-\lambda (t-s)} + e^{-\lambda t} \int_s^t e^{\lambda u} \phi(u)du + e^{-\lambda t} (M_t-M_s)|\mathcal{F}_s)\\

    &amp;=  X_se^{-\lambda (t-s)} + e^{-\lambda t} \int_s^t e^{\lambda u} \phi(u)du + e^{-\lambda t} E(M_t-M_s |\mathcal{F}_s)\\

    &amp;= X_se^{-\lambda (t-s)} + e^{-\lambda t} \int_s^t e^{\lambda u} \phi(u)du \text{,  car $M$ est une martingale}\\

\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}

    V(X_t|X_s) &amp;= V(X_se^{-\lambda (t-s)} + e^{-\lambda t} \int_s^t e^{\lambda u} \phi(u)du + e^{-\lambda t} (M_t-M_s)|\mathcal{F}_s)\\

                &amp;= e^{-2\lambda t}V(M_t-M_s|\mathcal{F}_s)\\

                &amp;= e^{-2\lambda t}E((M_t-M_s)^2|\mathcal{F}_s)\\

                &amp;= e^{-2\lambda t}E((M_t-M_s)^2) \text{,  car $M$  est a accroissements indépendants}\\

                &amp;= e^{-2\lambda t}\int_s^t e^{\lambda 2u}\sigma^2(u) du\\

                &amp;= \int_s^t e^{-\lambda 2(t-u)}\sigma^2(u) du\\

\end{align*}\]</span></p>
<p>Finalement,</p>
<p>$$</p>
<p>X_t|X_s ( X_se^{-(t-s)} + e^{-t} _s^t e^{u} (u)du,_s^t e<sup>{-(t-u)}</sup>2(u) du)</p>
<p>$$</p></li>
</ol>
<hr>
</section>
<section id="dynamique-des-taux-forwards" class="level2">
<h2 class="anchored" data-anchor-id="dynamique-des-taux-forwards">Dynamique des taux forwards</h2>
<hr>
<ol type="1">
<li><p>On a</p>
<p>$$</p>
<p>Z_t = ,</p>
<p>$$</p>
<p>avec</p>
<p>$$</p>
<p> = r_t dt + (t,T)dW_t^Q.</p>
<p>$$</p>
<p><span class="math display">\[\begin{align*}

     \frac{dZ_t}{Z_t} &amp;= \frac{dB(t,T_{i})}{B(t,T_{i})} - \frac{dB(t,T_{i+1})}{B(t,T_{i+1})} - \left&lt; \frac{dB(t,T_{i})}{B(t,T_{i})} - \frac{dB(t,T_{i+1})}{B(t,T_{i+1})} | \frac{dB(t,T_{i+1})}{B(t,T_{i+1})}\right&gt;\\

     &amp;= r_t dt + \Gamma(t,T_{i})dW_t^Q - r_t dt - \Gamma(t,T_{i+1})dW_t^Q - \notag \\

   &amp;\quad \left&lt; r_t dt + \Gamma(t,T_{i})dW_t^Q - r_t dt - \Gamma(t,T_{i+1})dW_t^Q | r_t dt + \Gamma(t,T_{i+1})dW_t^Q\right&gt;\\

     &amp;= \Gamma(t,T_{i})dW_t^Q - \Gamma(t,T_{i+1})dW_t^Q - \notag \\

   &amp;\quad \left&lt; \Gamma(t,T_{i})dW_t^Q - \Gamma(t,T_{i+1})dW_t^Q | r_t dt + \Gamma(t,T_{i+1})dW_t^Q\right&gt;\\

     &amp;= \Gamma(t,T_{i})dW_t^Q - \Gamma(t,T_{i+1})dW_t^Q -\Gamma(t,T_{i}) \Gamma(t,T_{i+1}) d&lt;W^Q&gt;_t + \notag \\

   &amp;\quad \Gamma^2(t,T_{i+1}) d&lt;W^Q&gt;_t\\

     &amp;= (\Gamma(t,T_{i})- \Gamma(t,T_{i+1}))(dW_t^Q - \Gamma(t,T_{i+1}) dt) \text{,  car $d&lt;W^Q&gt;_t = dt$}\\

     &amp;= (\Gamma(t,T_{i})- \Gamma(t,T_{i+1}))d\tilde{W}^Q_t \text{,   avec $d\tilde{W}^Q_t =dW_t^Q - \Gamma(t,T_{i+1}) dt$}\\

\end{align*}\]</span></p>
<p>D’où</p>
<p>$</p>
<p>Z_t = Z_0 .</p>
<p>$</p>
<p>En notant <span class="math inline">\(L_i(t)\)</span> le taux libor forward à la date <span class="math inline">\(t\)</span> qui fixe en <span class="math inline">\(T_i\)</span> et qui paye en <span class="math inline">\(T_{i+1}\)</span>, on a</p>
<p>$$</p>
<p>L_i(t) = ( - 1) = (Z_t - 1).</p>
<p>$$</p>
<p>On en déduit que</p>
<p>$</p>
<p>L_i(t) = - + (1 + _i L_i(0)) </p>
<p>$</p>
<p>$</p>
<p></p>
<p>$</p>
<p>En appliquant le lemme d’Îto à cette dernière égalité on obtient la dyanamique du taux libor forward donnée par:</p>
<p>$$</p>
<p>dL_i(t) = (L_i(t) + )((t,T_{i})- (t,T_{i+1}))d^Q_t.</p>
<p>$$</p></li>
</ol>
<hr>
</section>
<section id="valorisation-des-instruments-de-calibration" class="level2">
<h2 class="anchored" data-anchor-id="valorisation-des-instruments-de-calibration">Valorisation des instruments de calibration</h2>
<hr>
<ol type="1">
<li><p>Le payoff d’un caplet vanille sur taux libor <span class="math inline">\(L_i(T_i)\)</span>, de maturité <span class="math inline">\(T_i\)</span>, de date de paiement <span class="math inline">\(T_{i+1}\)</span> et de strike <span class="math inline">\(K\)</span> s’écrit</p>
<p>$$</p>
<p>Payoff(T_i, T_{i+1}, K) = _i(L_i(T_i) - K)^+.</p>
<p>$$</p></li>
<li><p>La formule de valorisation de ce caplet dans le cadre du modèle d’Hull and White</p>
<p><span class="math display">\[\begin{align*}

     B(0,T_{i+1})E(Payoff(T_i, T_{i+1}, K)) = B(0,T_{i+1})E(\delta_i(L_i(T_i) - K)^+)

\end{align*}\]</span></p>
<p>or</p>
<p><span class="math display">\[\begin{align*}

     Payoff(T_i, T_{i+1}, K) &amp;= \delta_i(L_i(T_i) - K)^+\\

     &amp;= \delta_i(\frac{1}{\delta_i} (Z_{T_i} - 1) - K)^+ \\

     &amp;= (Z_{T_i} - (\delta_iK + 1))^+ \\

     &amp;= (Z_{T_i} - \tilde{K})^+, \text{  avec $\tilde{K} = \delta_iK + 1$}

\end{align*}\]</span></p>
<p>Puisque la dynamique du processus <span class="math inline">\(Z\)</span> est décrite par le modèle de Black, on déduit de la remaque ci-dessus que le prix d’un caplet vanille sur taux libor <span class="math inline">\(L_i(T_i)\)</span>, de maturité <span class="math inline">\(T_i\)</span>, de date de paiement <span class="math inline">\(T_{i+1}\)</span> et de strike <span class="math inline">\(K\)</span> peut s’écrire sous la forme</p>
<p><span class="math display">\[\begin{align*}

     Caplet(T_i, T_{i+1}, K) &amp;= C(Z_{T_i},\tilde{K}, T_i, \sigma^*_i, B(0,T_{i+1}))

\end{align*}\]</span></p>
<p>$$</p>
<p>^*<em>i = <em>t^{T_i} ((u,T</em>{i})- (u,T</em>{i+1}))du<br>
</p>
<p>$$</p></li>
</ol>
<hr>
</section>
<section id="calibration-du-modèle" class="level2">
<h2 class="anchored" data-anchor-id="calibration-du-modèle">Calibration du modèle</h2>
<hr>
<ol type="1">
<li><p>On considère un caplet sur l’Euribor 12M de maturité <span class="math inline">\(5\)</span> ans, avec un strike at-the-money. Nous cherchons la volatilité implicite <span class="math inline">\(\sigma\)</span> telle que le prix modèle (Hull&amp;White) soit égal au prix observé sur le marché.</p>
<p>Pour ce faire, nous avons utilisé une méthode de type dichotomie pour estimer la volatilité implicite associée au processus <span class="math inline">\(Z_t\)</span>, et avons obtenu une valeur de <span class="math inline">\(\mathbf{0.9271} \%.\)</span></p>
<p>Dans un second temps, nous en avons déduit analytiquement le paramètre de volatilité instantanée du modèle, estimé à <span class="math inline">\(\mathbf{1.071}\%\)</span>.</p></li>
<li><p>Nous en déduisons les prix “modèles” des caplets, obtenus à partir de la volatilité calibrée précédemment, pour les strikes suivants : <strong>FWD</strong> <span class="math inline">\(\pm\)</span> <strong>25 bps, 50 bps</strong> et <strong>100 bps</strong>.</p></li>
</ol>
<div id="7ea14c2e" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatilité instantanée</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigma(T_i_1, T_i, lambd, vol):</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> (<span class="dv">1</span><span class="op">-</span>np.exp(<span class="op">-</span>lambd<span class="op">*</span>(T_i <span class="op">-</span> T_i_1)))<span class="op">/</span>lambd</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> np.sqrt((<span class="dv">2</span><span class="op">*</span>lambd<span class="op">*</span>T_i_1)<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>np.exp(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>lambd<span class="op">*</span>T_i_1))) <span class="op">*</span> vol <span class="op">/</span> beta</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigma</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Pricer du caplet HW</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> P_HW(t,Z, K, T_i_1, T_i, B, vol):</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    delta <span class="op">=</span> T_i <span class="op">-</span> T_i_1</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(Z<span class="op">/</span>K) <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> (vol<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>(T_i_1 <span class="op">-</span> t))<span class="op">/</span>(vol <span class="op">*</span> np.sqrt(T_i_1 <span class="op">-</span> t))</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> vol<span class="op">*</span>np.sqrt(T_i_1 <span class="op">-</span> t)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    caplet <span class="op">=</span> delta <span class="op">*</span> B[<span class="dv">1</span>] <span class="op">*</span> (Z <span class="op">*</span> norm.cdf(d1) <span class="op">-</span> K <span class="op">*</span> norm.cdf(d2))</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> caplet</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="2ab52187" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialisation des paramètres</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>T_i_1 <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>T_i <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>lambd <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>P_MKT <span class="op">=</span> <span class="fl">0.7137</span> <span class="op">/</span> <span class="dv">100</span> <span class="co"># Prix du marché</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.array([yield_zc[yield_zc.MAT<span class="op">==</span>T_i_1][<span class="st">"B(0,MAT)"</span>],</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>yield_zc[yield_zc.MAT<span class="op">==</span>T_i][<span class="st">"B(0,MAT)"</span>] ])</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> B[<span class="dv">0</span>] <span class="op">/</span> B[<span class="dv">1</span>]</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> (Z<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>(T_i<span class="op">-</span>T_i_1)</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>K_tilde <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> (T_i<span class="op">-</span>T_i_1)<span class="op">*</span>K</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>L_0 <span class="op">=</span> (Z<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>(T_i<span class="op">-</span>T_i_1) <span class="co"># Taux libor</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="82f00aca" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Recherche de la vol implicite par dichotomie</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dichot(t,Z, K_tilde, T_i_1, T_i, B, P_MKT):</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    sig_inf <span class="op">=</span> <span class="fl">1e-8</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    sig_sup <span class="op">=</span> <span class="fl">1e1</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    epsi <span class="op">=</span> <span class="fl">1e-8</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    sig_moy <span class="op">=</span> (sig_inf <span class="op">+</span> sig_sup)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    error <span class="op">=</span> sig_sup <span class="op">-</span> sig_inf</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> error<span class="op">&gt;</span>epsi:</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        p_hw <span class="op">=</span> P_HW(t,Z, K_tilde, T_i_1, T_i, B, vol<span class="op">=</span>sig_moy)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p_hw <span class="op">&gt;</span> P_MKT:</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>            sig_sup <span class="op">=</span> sig_moy</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> p_hw <span class="op">&lt;</span> P_MKT:</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            sig_inf <span class="op">=</span> sig_moy</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>        sig_moy <span class="op">=</span> (sig_inf <span class="op">+</span> sig_sup)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>        error <span class="op">=</span> np.<span class="bu">abs</span>(sig_sup <span class="op">-</span> sig_inf)</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sig_moy</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="64b3c8ef" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Vol implicte optimale</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>vol_imp <span class="op">=</span> dichot(t,Z, K_tilde, T_i_1, T_i, B, P_MKT)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>vol_imp</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>0.009270474060870853</code></pre>
</div>
</div>
<div id="f1d5205c" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Vol instantanée</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>vol_inst <span class="op">=</span> sigma(T_i_1, T_i, lambd, vol<span class="op">=</span>vol_imp)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>vol_inst</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>np.float64(0.01071380211500768)</code></pre>
</div>
</div>
<div id="f36b99d5" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Vérification dui matching du prix du marché par le pricer</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>P_HW(t,Z, K_tilde, T_i_1, T_i, B, vol_imp)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>array([0.007137])</code></pre>
</div>
</div>
<div id="3e8069c2" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>strikes <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">100</span>, <span class="op">-</span><span class="dv">50</span>, <span class="op">-</span><span class="dv">25</span>, <span class="dv">0</span>, <span class="dv">25</span>, <span class="dv">50</span>, <span class="dv">100</span>])<span class="op">/</span><span class="dv">10_000</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>caplets <span class="op">=</span> np.array([P_HW(t,Z, <span class="dv">1</span> <span class="op">+</span> (T_i<span class="op">-</span>T_i_1)<span class="op">*</span>(K<span class="op">+</span>strike), T_i_1, T_i, B, vol_imp) <span class="cf">for</span> strike <span class="kw">in</span> strikes])</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Préparation des données pour le tableau</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>table_data <span class="op">=</span> []</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(caplets)):</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    table_data.append([strikes[i]<span class="op">*</span><span class="dv">10_000</span>, np.<span class="bu">round</span>(caplets[i]<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>)])</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage des résultats dans un tableau</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>headers <span class="op">=</span> [<span class="st">"Strike (bps)"</span>, <span class="st">"Prix Modèle du Caplet (%)"</span>]</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tabulate(table_data, headers<span class="op">=</span>headers, tablefmt<span class="op">=</span><span class="st">"pretty"</span>, floatfmt<span class="op">=</span><span class="st">".4f"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>+--------------+---------------------------+
| Strike (bps) | Prix Modèle du Caplet (%) |
+--------------+---------------------------+
|    -100.0    |           [1.2]           |
|    -50.0     |          [0.94]           |
|    -25.0     |          [0.82]           |
|     0.0      |          [0.71]           |
|     25.0     |          [0.62]           |
|     50.0     |          [0.53]           |
|    100.0     |          [0.38]           |
+--------------+---------------------------+</code></pre>
</div>
</div>
<div id="33c6e91e" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>plt.plot(strikes<span class="op">*</span><span class="dv">10_000</span>, caplets<span class="op">*</span><span class="dv">100</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Strikes (bps)"</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Prix modèle (%)"</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Prix modèle en fonction des strikes"</span>)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2575563213.py:11: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.
  plt.legend()</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-23-output-2.png" width="589" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<ol start="2" type="1">
<li>Inversons ces prix modèle à l’aide de la fonction de Black pour calculer les volatilités implicites.</li>
</ol>
<p>Les volatilités implicites retrouvés pour ces prix modèles sont resumés dans le tableau ci après:</p>
<div id="f4f739a9" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inversion des prix pour retrouver la vol implicite</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>L_i <span class="op">=</span> (Z<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>(T_i<span class="op">-</span>T_i_1)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>vols <span class="op">=</span> np.array([dichot(t,L_i, strike <span class="op">+</span> K, T_i_1, T_i, B, caplet) <span class="cf">for</span> strike,caplet <span class="kw">in</span> <span class="bu">zip</span>(strikes,caplets)])</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co">#vols_inst = np.array([sigma(T_i_1, T_i, lambd, vol=vol) for vol in vols])</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Préparation des données pour le tableau</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>table_data <span class="op">=</span> []</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(caplets)):</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>    table_data.append([strikes[i]<span class="op">*</span><span class="dv">10_000</span>, np.<span class="bu">round</span>(vols[i]<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>), np.<span class="bu">round</span>(caplets[i]<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>)])</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage des résultats dans un tableau</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>headers <span class="op">=</span> [<span class="st">"Strike (bps)"</span>, <span class="st">"Vol implicite (%)"</span>, <span class="st">"Prix Modèle du Caplet (%)"</span>]</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tabulate(table_data, headers<span class="op">=</span>headers, tablefmt<span class="op">=</span><span class="st">"pretty"</span>, floatfmt<span class="op">=</span><span class="st">".4f"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>+--------------+-------------------+---------------------------+
| Strike (bps) | Vol implicite (%) | Prix Modèle du Caplet (%) |
+--------------+-------------------+---------------------------+
|    -100.0    |       28.87       |           [1.2]           |
|    -50.0     |       26.74       |          [0.94]           |
|    -25.0     |       25.83       |          [0.82]           |
|     0.0      |       25.0        |          [0.71]           |
|     25.0     |       24.24       |          [0.62]           |
|     50.0     |       23.55       |          [0.53]           |
|    100.0     |       22.3        |          [0.38]           |
+--------------+-------------------+---------------------------+</code></pre>
</div>
</div>
<hr>
<p><strong>Comparons le smile modèle avec le smile de marché</strong></p>
<div id="e5ff0566" class="cell" data-execution_count="24">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>vol_mkt <span class="op">=</span> np.array([<span class="fl">31.2</span>, <span class="fl">28.4</span>, <span class="fl">26.6</span>, <span class="fl">25.0</span>, <span class="fl">24.4</span>, <span class="fl">25.0</span>, <span class="fl">27.2</span>])</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>plt.plot(strikes<span class="op">*</span><span class="dv">10_000</span>, vols<span class="op">*</span><span class="dv">100</span>, label<span class="op">=</span><span class="st">"Vol implicite"</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>plt.plot(strikes<span class="op">*</span><span class="dv">10_000</span>, vol_mkt, label<span class="op">=</span><span class="st">"Vol de marché"</span>,  marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Strikes (bps)"</span>)</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Volatilité (%)"</span>)</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Volatilités en fonction des strikes"</span>)</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-25-output-1.png" width="585" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<p>On observe pour ce modèle un <strong>Skew-Smile</strong>. Le modèle de Hull &amp; white n’arrive pas à reproduire le smile de marché. .</p>
<hr>
<hr>
</section>
<section id="valorisation-dun-produit-structuré" class="level2">
<h2 class="anchored" data-anchor-id="valorisation-dun-produit-structuré">Valorisation d’un produit structuré</h2>
<p>Nous souhaitons valoriser un caplet</p>
<ul>
<li><p>de strike K,</p></li>
<li><p>de dates de fixing <span class="math inline">\(T_i\)</span> et de paiement <span class="math inline">\(T_{i+1}\)</span>,</p></li>
<li><p>avec une barrière désactivante <span class="math inline">\(B\)</span> telle que <span class="math inline">\(B &gt; K\)</span>.</p></li>
</ul>
<ol type="1">
<li><p>Écrivons le payoff de l’option décrite et traçons la fonction de payoff en fonction de <span class="math inline">\(L_i(T_i)\)</span>.</p>
<p>Le payoff l’option s’écrit :</p>
<p>$$</p>
<p><em>{T</em>{i+1}} = <em>i (L_i(T_i) - K)^+ </em>{{ L_i(T_i) &lt; B }}</p>
<p>$$</p>
<p>avec <span class="math inline">\(\delta_i = T_{i+1}-T_i\)</span>.</p>
<p>Il correspond à celui d’un caplet classique, mais est nul lorsque le taux Libor au fixing dépasse la barrière.</p>
<p>Ainsi, fonction de payoff est donc nulle pour <span class="math inline">\(L_i(T_i) &lt; K\)</span> ou <span class="math inline">\(L_i(T_i) \geq B\)</span>, et croît linéairement entre <span class="math inline">\(K\)</span> et $ B$.</p>
<p>Une representation de la fonction de payoff est donnée la figure ci-dessous.</p></li>
</ol>
<div id="b0a48f55" class="cell" data-execution_count="25">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">#3.7. </span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co">#1. Payoff et courbe</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Définition des paramètres</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>Z_T <span class="op">=</span> <span class="fl">1.05</span>  <span class="co"># Exemple de valeur pour Z_T</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="fl">0.4</span>  <span class="co"># Barrière (B)</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Définition des valeurs possibles pour Li(Ti)</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>Li_Ti <span class="op">=</span> np.linspace(<span class="fl">0.001</span>, <span class="fl">0.5</span>, <span class="dv">500</span>)</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcul du payoff du caplet désactivant</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>payoff <span class="op">=</span> np.maximum(<span class="dv">0</span>, Li_Ti <span class="op">-</span> K) <span class="op">*</span> (Li_Ti <span class="op">&lt;</span> B)</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Tracé de la fonction de payoff</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>plt.plot(Li_Ti, payoff, label<span class="op">=</span><span class="st">'Payoff du Caplet Désactivant'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>K, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Strike (K)'</span>)</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>B, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">'Barrière (B)'</span>)</span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Fonction de Payoff d</span><span class="ch">\'</span><span class="st">un Caplet Désactivant'</span>)</span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Li(Ti)'</span>)</span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Payoff'</span>)</span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-26-output-1.png" width="672" height="524" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<p>Cette option est moins chère qu’un caplet classique de strike <span class="math inline">\(K\)</span> car elle comporte une barrière désactivante qui limite le risque pour le vendeur. En effet, dès que le taux dépasse $B $, le caplet est désactivé, ce qui protège le vendeur contre les scénarios de forte hausse de taux.</p>
<p>Du point de vue de l’acheteur, cette protection a un coût : l’option devient moins attractive, car elle ne couvre plus les situations les plus défavorables. La probabilité de recevoir un payoff est donc réduite, ce qui justifie un prix plus bas par rapport à un caplet standard.</p>
<ol start="2" type="1">
<li><p>Le payoff de cet option est semblable à celui de:</p>
<ul>
<li><p>l’achat d’un caplet de stkire K: <span class="math inline">\((L_i(T_i) - K)^+\)</span> ,</p></li>
<li><p>de la vente d’un caplet de strike B: <span class="math inline">\(-(L_i(T_i) - B)^+\)</span>,</p></li>
<li><p>et d’un paiement fixe déclenché par le franchissement de la barrière: <span class="math inline">\(-(B-K)\mathbb{1}_{\{ L_i(T_i) &gt; B \}}\)</span></p></li>
</ul></li>
</ol>
<p>Le payoff peut alors se réécrire comme suit :</p>
<p>$$</p>
<pre><code>\text{Payoff}_{T_{i+1}} = \delta_i \cdot( (L_i(T_i) - K)^+ -(L_i(T_i) - B)^+ -(B-K)\mathbb{1}_{\{ L_i(T_i) &gt; B \}})

$$</code></pre>
<p>La prise en compte du smile de volatilité est indispensable pour deux raisons principales. Premièrement, elle permet de modéliser les variations du sous-jacent (ici, le taux Libor), qui influencent directement la valeur de l’option. Deuxièmement, elle est cruciale pour évaluer l’effet de la barrière : une volatilité élevée accroît la probabilité que le taux Libor dépasse la barrière, désactivant ainsi l’option, tandis qu’une faible volatilité réduit cette probabilité, maintenant l’option active.</p>
<ol start="3" type="1">
<li><p>La méthode de Monte-Carlo repose sur des simulations aléatoires pour estimer la valeur attendue d’un payoff futur, actualisé à aujourd’hui. Cette méthode repose sur la loi des grands nombres : si l’on simule un grand nombre de scénarios possibles pour l’évolution du sous-jacent (les taux d’intérêt pour ce qui nous concerne), la moyenne des payoffs actualisés converge vers le prix théorique de l’instrument</p></li>
<li><p>On peut générer une variable gaussienne standard <span class="math inline">\(Z \sim \mathcal{N}(0,1)\)</span> à partir d’une variable uniforme <span class="math inline">\(U \sim \mathcal{U}(0,1)\)</span> en utilisant la réciproque de la fonction de répartition:</p>
<p>$$</p>
<p>Z = ^{-1}(U)</p>
<p>$$</p></li>
<li><p>On considère un caplet sur euribor12M à barrière désactivante</p>
<ul>
<li><p>de strike <span class="math inline">\(ATM-100\)</span> bps,</p></li>
<li><p>de barrière <span class="math inline">\(ATM+100\)</span> 100 bps et</p></li>
<li><p>de maturité 5Y.</p></li>
</ul>
<p>Alors, sa valeur calculée à l’aide de la méthode de Monte-Carlo est de 0.29%.</p></li>
</ol>
<hr>
<div id="18ca89ee" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> B(t,T, x, lambd, sig):</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> beta(t,T):</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="dv">1</span><span class="op">-</span> np.exp(<span class="op">-</span>lambd<span class="op">*</span>(T<span class="op">-</span>t)))<span class="op">/</span>lambd</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> phi(t):</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (sig<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>np.exp(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>lambd<span class="op">*</span>t))<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>lambd)</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    B_t <span class="op">=</span> <span class="bu">float</span>(yield_zc[yield_zc.MAT<span class="op">==</span>t][<span class="st">"B(0,MAT)"</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    B_T <span class="op">=</span>  <span class="bu">float</span>(yield_zc[yield_zc.MAT<span class="op">==</span>T][<span class="st">"B(0,MAT)"</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    bet <span class="op">=</span> beta(t,T)</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    B_t_T <span class="op">=</span> (B_T<span class="op">/</span>B_t) <span class="op">*</span> np.exp(<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>phi(t)<span class="op">*</span>(bet<span class="op">**</span><span class="dv">2</span>)<span class="op">-</span>bet<span class="op">*</span>x)</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B_t_T</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> option_vanille(T, delta, K, sig, lambd, barrier, M<span class="op">=</span><span class="dv">10_000</span>):</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Number of time steps (daily steps for T years)</span></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">round</span>(T <span class="op">*</span> <span class="dv">252</span>)</span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>    Delta <span class="op">=</span> T <span class="op">/</span> n  <span class="co"># Time step size</span></span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>    t_vec <span class="op">=</span> np.arange(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> Delta  <span class="co"># Time steps</span></span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate paths of X_t</span></span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((M, n))</span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>        phi_t <span class="op">=</span> (sig<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> lambd)) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">2</span> <span class="op">*</span> lambd <span class="op">*</span> t_vec[t]))</span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a>        gamma_t_T <span class="op">=</span> (sig <span class="op">/</span> lambd) <span class="op">*</span> (np.exp(<span class="op">-</span>lambd <span class="op">*</span> (T <span class="op">-</span> t_vec[t])) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Euler-Maruyama discretization</span></span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>        X[:, t <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> X[:, t] <span class="op">+</span> (phi_t <span class="op">+</span> sig <span class="op">*</span> gamma_t_T <span class="op">-</span> lambd <span class="op">*</span> X[:, t]) <span class="op">*</span> Delta <span class="op">+</span> sig <span class="op">*</span> np.sqrt(Delta) <span class="op">*</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, size<span class="op">=</span>M)</span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-65"><a href="#cb38-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-66"><a href="#cb38-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-67"><a href="#cb38-67" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate Libor rates for each path</span></span>
<span id="cb38-68"><a href="#cb38-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-69"><a href="#cb38-69" aria-hidden="true" tabindex="-1"></a>    L_i <span class="op">=</span> np.array([((<span class="dv">1</span> <span class="op">/</span> B(T, T <span class="op">+</span> delta, X[:, t], lambd, sig)) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> delta <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(n)])</span>
<span id="cb38-70"><a href="#cb38-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-71"><a href="#cb38-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-72"><a href="#cb38-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-73"><a href="#cb38-73" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Barrier condition</span></span>
<span id="cb38-74"><a href="#cb38-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-75"><a href="#cb38-75" aria-hidden="true" tabindex="-1"></a>    L_i_B <span class="op">=</span> (L_i[<span class="op">-</span><span class="dv">1</span>,:] <span class="op">&lt;</span> barrier).astype(<span class="bu">int</span>)</span>
<span id="cb38-76"><a href="#cb38-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-77"><a href="#cb38-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-78"><a href="#cb38-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-79"><a href="#cb38-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Payoff calculation</span></span>
<span id="cb38-80"><a href="#cb38-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-81"><a href="#cb38-81" aria-hidden="true" tabindex="-1"></a>    payoff <span class="op">=</span> np.maximum(L_i[<span class="op">-</span><span class="dv">1</span>,:] <span class="op">-</span> K, <span class="dv">0</span>) <span class="op">*</span> L_i_B</span>
<span id="cb38-82"><a href="#cb38-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-83"><a href="#cb38-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-84"><a href="#cb38-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-85"><a href="#cb38-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Discounting</span></span>
<span id="cb38-86"><a href="#cb38-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-87"><a href="#cb38-87" aria-hidden="true" tabindex="-1"></a>    B_T_delta <span class="op">=</span> <span class="bu">float</span>(yield_zc[yield_zc.MAT <span class="op">==</span> T <span class="op">+</span> delta][<span class="st">"B(0,MAT)"</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb38-88"><a href="#cb38-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-89"><a href="#cb38-89" aria-hidden="true" tabindex="-1"></a>    option_price <span class="op">=</span> B_T_delta <span class="op">*</span> np.mean(payoff)</span>
<span id="cb38-90"><a href="#cb38-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-91"><a href="#cb38-91" aria-hidden="true" tabindex="-1"></a>    option_std <span class="op">=</span> np.std(B_T_delta<span class="op">*</span>payoff)</span>
<span id="cb38-92"><a href="#cb38-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-93"><a href="#cb38-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plt.plot(L_i[:,:1000])</span></span>
<span id="cb38-94"><a href="#cb38-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-95"><a href="#cb38-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-96"><a href="#cb38-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-97"><a href="#cb38-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([option_price, option_std]) <span class="co"># prix et ecart-type de l'option</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>La valeur de l’option calculée à l’aide de la méthode de Monte-Carlo est de 0.29% pour 10 000 simulations.</p>
<hr>
<div id="7ccc842d" class="cell" data-execution_count="27">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">90</span>) <span class="co"># Pour la reproductibilité</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>barrier <span class="op">=</span> L_0 <span class="op">+</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span> </span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> L_0 <span class="op">-</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> option_vanille(T <span class="op">=</span> <span class="dv">5</span>, delta <span class="op">=</span> <span class="dv">1</span>, K <span class="op">=</span> K, sig <span class="op">=</span> vol_inst, lambd <span class="op">=</span> lambd, barrier <span class="op">=</span> barrier, M<span class="op">=</span><span class="dv">10_000</span>)</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Prix du caplet: </span><span class="ch">\t</span><span class="st">"</span>, L[<span class="dv">0</span>])</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Standard error du caplet: </span><span class="ch">\t</span><span class="st">"</span>, L[<span class="dv">1</span>])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Prix du caplet:      0.002952664054116537
Standard error du caplet:    0.0048520375617754595</code></pre>
</div>
</div>
<div id="bc97f630" class="cell" data-execution_count="28">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span>  np.arange(<span class="dv">100</span>, <span class="dv">10_000</span>, <span class="dv">500</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>cap_prices <span class="op">=</span> np.array([option_vanille(T <span class="op">=</span> <span class="dv">5</span>, delta <span class="op">=</span> <span class="dv">1</span>, K <span class="op">=</span> K, sig <span class="op">=</span> vol_inst, lambd <span class="op">=</span> lambd, barrier <span class="op">=</span> barrier, M<span class="op">=</span>m) <span class="cf">for</span> m <span class="kw">in</span> M])</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>plt.plot(M, cap_prices[:,<span class="dv">0</span>], label<span class="op">=</span><span class="st">"Caplet MC price avec intervalle de confiance à 95%"</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>plt.plot(M, cap_prices[:,<span class="dv">0</span>] <span class="op">+</span> <span class="fl">1.96</span><span class="op">*</span>cap_prices[:,<span class="dv">1</span>], label<span class="op">=</span><span class="st">"Upper bound"</span>, linestyle<span class="op">=</span><span class="st">"dashed"</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>plt.plot(M, cap_prices[:,<span class="dv">0</span>] <span class="op">-</span> <span class="fl">1.96</span><span class="op">*</span>cap_prices[:,<span class="dv">1</span>], label<span class="op">=</span><span class="st">"Lower bound"</span>, linestyle<span class="op">=</span><span class="st">"dashed"</span>, color<span class="op">=</span><span class="st">'red'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-29-output-1.png" width="616" height="411" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<ol start="6" type="1">
<li><p>La dégénération du produit en faisant tendre la barrière vers 0 et <span class="math inline">\(+\infty\)</span> est donnée par la figure ci-dessous.</p>
<ul>
<li><p>On contate que le prix de l’option tend à s’annuler à mesure que la barrière tends vers 0 et il tend à être constant à mesure que la barrière tend vers <span class="math inline">\(+\infty\)</span>.</p></li>
<li><p>Ceci traduit le fait que l’option devient de moins en moins attractifs pour des barrières très basses et s’apprécie pour des barrières élevées (il devient moins probable de la franchir).</p></li>
</ul></li>
</ol>
<hr>
<div id="a4b305f2" class="cell" data-execution_count="29">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">90</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>barriers <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>, num<span class="op">=</span><span class="dv">50</span>) <span class="co"># Différentes barrières</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> L_0 <span class="op">-</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>caplets_barrier <span class="op">=</span> np.array([option_vanille(T <span class="op">=</span> <span class="dv">5</span>, delta <span class="op">=</span> <span class="dv">1</span>, K <span class="op">=</span> K, sig <span class="op">=</span> vol_inst, lambd <span class="op">=</span> lambd, barrier <span class="op">=</span> barrier) <span class="cf">for</span> barrier <span class="kw">in</span> barriers])</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>plt.plot(barriers, caplets_barrier, label <span class="op">=</span><span class="st">"Prix de l'option"</span>)</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Barrières"</span>)</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Prix de l'option"</span>)</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Prix de l'option en fonction du niveau de la barrière"</span>)</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-30-output-1.png" width="606" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="258ebc68" class="cell" data-execution_count="30">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">90</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>barrier <span class="op">=</span> <span class="dv">10</span> <span class="co"># Barrière à 1000%</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> L_0 </span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> option_vanille(T <span class="op">=</span> <span class="dv">5</span>, delta <span class="op">=</span> <span class="dv">1</span>, K <span class="op">=</span> L_0, sig <span class="op">=</span> vol_inst, lambd <span class="op">=</span> lambd, barrier <span class="op">=</span> barrier, M<span class="op">=</span><span class="dv">10_000</span>)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(L)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[0.0074075  0.01072443]</code></pre>
</div>
</div>
<ol start="7" type="1">
<li><p>La barrière est rendue “bermudéenne” en étendant la condition de désactivation aux dates 1Y, 2Y, 3Y, 4Y et 5Y.</p>
<p>La nouvelle fonction de payoff s’écrit:</p>
<p><span class="math display">\[\begin{align*}

     \text{Payoff}_{T_{i+1}} &amp;= \begin{cases}

         \delta_i \cdot (L_i(T_i) - K)^+ \text{ si aucune la barrière n'est franchie en aucune date } T_j \\

         0 \text{ si la barrière est franchie au moins une fois}

     \end{cases} \\

     &amp;=\delta_i \cdot (L_i(T_i) - K)^+ \cdot \mathbb{1}_{\{max_{1\leq j \leq 5} L_i(T_j) &lt; B \}}\\  

\end{align*}\]</span></p></li>
</ol>
<div id="a537661f" class="cell" data-execution_count="31">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Pricer d'une option bermudéenne</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> option_vanille_bermude(T, delta, K, sig, lambd, barrier, M<span class="op">=</span><span class="dv">10_000</span>):</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Valorisation d'un caplet avec barrière bermudéenne via Monte Carlo.</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Paramètres :</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="co">    - T : Dates d'exercice bermudéennes (ex. [1, 2, 3, 4, 5] ans)</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="co">    - delta : Intervalle de temps entre la date de fixing et la date de paiement</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a><span class="co">    - K : Strike du caplet</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a><span class="co">    - sig : Volatilité du taux d'intérêt</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a><span class="co">    - lambd : Paramètre de régression vers la moyenne du taux court</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a><span class="co">    - barrier : Barrière désactivante</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a><span class="co">    - yield_zc : Courbe des taux zéro-coupon (DataFrame avec colonnes 'MAT' et 'B(0,MAT)')</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a><span class="co">    - M : Nombre de simulations Monte Carlo</span></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Discrétisation temporelle : pas de temps quotidien</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">round</span>(T[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="dv">252</span>)  <span class="co"># Nombre total de pas de temps</span></span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a>    Delta <span class="op">=</span> T[<span class="op">-</span><span class="dv">1</span>] <span class="op">/</span> n  <span class="co"># Taille du pas de temps</span></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a>    t_vec <span class="op">=</span> np.arange(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> Delta  <span class="co"># Vecteur des dates simulées</span></span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulation des trajectoires du taux court via un processus de Vasicek/Hull-White</span></span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-47"><a href="#cb45-47" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((M, n))</span>
<span id="cb45-48"><a href="#cb45-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-49"><a href="#cb45-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb45-50"><a href="#cb45-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-51"><a href="#cb45-51" aria-hidden="true" tabindex="-1"></a>        phi_t <span class="op">=</span> (sig<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> lambd)) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">2</span> <span class="op">*</span> lambd <span class="op">*</span> t_vec[t]))</span>
<span id="cb45-52"><a href="#cb45-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-53"><a href="#cb45-53" aria-hidden="true" tabindex="-1"></a>        gamma_t_T <span class="op">=</span> (sig <span class="op">/</span> lambd) <span class="op">*</span> (np.exp(<span class="op">-</span>lambd <span class="op">*</span> (T[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> t_vec[t])) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb45-54"><a href="#cb45-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-55"><a href="#cb45-55" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb45-56"><a href="#cb45-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-57"><a href="#cb45-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Euler</span></span>
<span id="cb45-58"><a href="#cb45-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-59"><a href="#cb45-59" aria-hidden="true" tabindex="-1"></a>        X[:, t <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> X[:, t] <span class="op">+</span> (phi_t <span class="op">+</span> sig <span class="op">*</span> gamma_t_T <span class="op">-</span> lambd <span class="op">*</span> X[:, t]) <span class="op">*</span> Delta <span class="op">+</span> sig <span class="op">*</span> np.sqrt(Delta) <span class="op">*</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, size<span class="op">=</span>M)</span>
<span id="cb45-60"><a href="#cb45-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-61"><a href="#cb45-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-62"><a href="#cb45-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-63"><a href="#cb45-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Vérification de la désactivation bermudéenne aux dates spécifiques</span></span>
<span id="cb45-64"><a href="#cb45-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-65"><a href="#cb45-65" aria-hidden="true" tabindex="-1"></a>    T_surveillance <span class="op">=</span> np.array(T)  <span class="co"># Dates de surveillance de la barrière</span></span>
<span id="cb45-66"><a href="#cb45-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-67"><a href="#cb45-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-68"><a href="#cb45-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-69"><a href="#cb45-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul des L_i aux dates de surveillance</span></span>
<span id="cb45-70"><a href="#cb45-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-71"><a href="#cb45-71" aria-hidden="true" tabindex="-1"></a>    L_i_surveillance <span class="op">=</span> np.zeros((M, <span class="bu">len</span>(T_surveillance)))</span>
<span id="cb45-72"><a href="#cb45-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-73"><a href="#cb45-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, T_i <span class="kw">in</span> <span class="bu">enumerate</span>(T_surveillance):</span>
<span id="cb45-74"><a href="#cb45-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-75"><a href="#cb45-75" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> <span class="bu">round</span>(T_i <span class="op">*</span> <span class="dv">252</span>) <span class="op">-</span> <span class="dv">1</span>  <span class="co"># Indice temporel à la date de surveillance</span></span>
<span id="cb45-76"><a href="#cb45-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-77"><a href="#cb45-77" aria-hidden="true" tabindex="-1"></a>        L_i_surveillance[:, i] <span class="op">=</span> ((<span class="dv">1</span> <span class="op">/</span> B(T_i, T_i <span class="op">+</span> delta, X[:, idx], lambd, sig)) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> delta  <span class="co"># Libor forward</span></span>
<span id="cb45-78"><a href="#cb45-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-79"><a href="#cb45-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-80"><a href="#cb45-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-81"><a href="#cb45-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Désactivation si la barrière est franchie à une date de surveillance</span></span>
<span id="cb45-82"><a href="#cb45-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-83"><a href="#cb45-83" aria-hidden="true" tabindex="-1"></a>    barrier_crossed <span class="op">=</span> np.<span class="bu">any</span>(L_i_surveillance <span class="op">&gt;=</span> barrier, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb45-84"><a href="#cb45-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-85"><a href="#cb45-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-86"><a href="#cb45-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-87"><a href="#cb45-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-88"><a href="#cb45-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-89"><a href="#cb45-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul des payoffs à la date de maturité</span></span>
<span id="cb45-90"><a href="#cb45-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-91"><a href="#cb45-91" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> <span class="bu">round</span>(T[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="dv">252</span>) <span class="op">-</span> <span class="dv">1</span>  <span class="co"># Indice temporel à la maturité</span></span>
<span id="cb45-92"><a href="#cb45-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-93"><a href="#cb45-93" aria-hidden="true" tabindex="-1"></a>    L_i_maturity <span class="op">=</span> ((<span class="dv">1</span> <span class="op">/</span> B(T[<span class="op">-</span><span class="dv">1</span>], T[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> delta, X[:, idx], lambd, sig)) <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> delta  <span class="co"># Libor forward</span></span>
<span id="cb45-94"><a href="#cb45-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-95"><a href="#cb45-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-96"><a href="#cb45-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-97"><a href="#cb45-97" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Payoff du caplet</span></span>
<span id="cb45-98"><a href="#cb45-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-99"><a href="#cb45-99" aria-hidden="true" tabindex="-1"></a>    payoff <span class="op">=</span> np.maximum(<span class="dv">0</span>, L_i_maturity <span class="op">-</span> K)  <span class="co"># Payoff à la maturité</span></span>
<span id="cb45-100"><a href="#cb45-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-101"><a href="#cb45-101" aria-hidden="true" tabindex="-1"></a>    payoff[barrier_crossed] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># Désactivation complète</span></span>
<span id="cb45-102"><a href="#cb45-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-103"><a href="#cb45-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-104"><a href="#cb45-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-105"><a href="#cb45-105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Actualisation et valorisation</span></span>
<span id="cb45-106"><a href="#cb45-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-107"><a href="#cb45-107" aria-hidden="true" tabindex="-1"></a>    B_T_delta <span class="op">=</span> <span class="bu">float</span>(yield_zc[yield_zc.MAT <span class="op">==</span> T[<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> delta][<span class="st">"B(0,MAT)"</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb45-108"><a href="#cb45-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-109"><a href="#cb45-109" aria-hidden="true" tabindex="-1"></a>    option_price <span class="op">=</span> B_T_delta <span class="op">*</span> np.mean(payoff)</span>
<span id="cb45-110"><a href="#cb45-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-111"><a href="#cb45-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-112"><a href="#cb45-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-113"><a href="#cb45-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([option_price, np.mean(barrier_crossed)]) <span class="co"># retourn le prix de l'option ainsi que </span></span>
<span id="cb45-114"><a href="#cb45-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-115"><a href="#cb45-115" aria-hidden="true" tabindex="-1"></a>                                                            <span class="co"># la proba de franchissement de la barrière</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<div id="f874f60f" class="cell" data-execution_count="32">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">90</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>barrier <span class="op">=</span> L_0 <span class="op">+</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> L_0 <span class="op">-</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>cap <span class="op">=</span> option_vanille_bermude(T <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]), delta <span class="op">=</span> <span class="dv">1</span>, K <span class="op">=</span> K, sig <span class="op">=</span> vol_inst, lambd <span class="op">=</span> lambd, barrier <span class="op">=</span> barrier)</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Prix de l'option bermudéenne: </span><span class="ch">\t</span><span class="st">"</span>, <span class="bu">round</span>(cap[<span class="dv">0</span>]<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>), <span class="st">"%"</span>)</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Probabilité d'atteinte de la barrière: </span><span class="ch">\t</span><span class="st">"</span>, <span class="bu">round</span>(cap[<span class="dv">1</span>]<span class="op">*</span><span class="dv">100</span>, <span class="dv">2</span>), <span class="st">"%"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Prix de l'option bermudéenne:    0.22 %
Probabilité d'atteinte de la barrière:   40.78 %</code></pre>
</div>
</div>
<p>Avec un strike <span class="math inline">\(ATM-100\)</span> et une barrière <span class="math inline">\(ATM+100\)</span>, le prix de cette option est de <span class="math inline">\(0.22\%\)</span>.</p>
<ul>
<li><p>On constate que cette option est moins chère que la précédente.</p></li>
<li><p>Ce résultat est conforme à nos attentes. En effet, avec plus de conditions de désactivation, l’option bermudéenne a une valeur intrinsèque plus faible, car elle est plus susceptible d’être désactivée avant la date de maturité.</p></li>
<li><p>Cela reflète le fait que le porteur de l’option est exposé à un risque plus élevé de perdre son payoff, tandis que le vendeur se protège contre des variations défavorables des taux à plusieurs dates.</p></li>
</ul>
<hr>
<ol start="8" type="1">
<li><p>L’impact de la mean reversion sur la valorisation de l’option est illustré par la figure ci-après.</p>
<p><em>NB</em>: Le modèle est recalibré sur le même caplet ATM pour chaque valeur de mean-reversion</p></li>
</ol>
<div id="0deb8aee" class="cell" data-execution_count="33">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>barrier <span class="op">=</span> L_0 <span class="op">+</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> L_0 <span class="op">-</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>lambdas <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>, num<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>cap_mean_rev <span class="op">=</span> np.array([option_vanille_bermude(T <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]), delta <span class="op">=</span> <span class="dv">1</span>, K <span class="op">=</span> K,</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>                                                sig <span class="op">=</span> sigma(<span class="dv">5</span>, <span class="dv">6</span>, lambd, vol<span class="op">=</span>vol_imp), <span class="co"># On recalibre la vol pour chaque lambda</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>                                                lambd <span class="op">=</span> lambd,</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>                                                barrier <span class="op">=</span> barrier) <span class="cf">for</span> lambd <span class="kw">in</span> lambdas] )</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>plt.plot(lambdas, cap_mean_rev[:,<span class="dv">0</span>], label <span class="op">=</span><span class="st">"Prix de l'option"</span>)</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Mean reversion ($</span><span class="er">\</span><span class="st">lambda$)"</span>)</span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Prix de l'option"</span>)</span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Prix de l'option en fonction de la mean reversion"</span>)</span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>&lt;&gt;:21: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
&lt;&gt;:21: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\1195450163.py:21: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
  plt.xlabel("Mean reversion ($\lambda$)")
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2512216972.py:7: RuntimeWarning: invalid value encountered in scalar divide
  beta = (1-np.exp(-lambd*(T_i - T_i_1)))/lambd
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2512216972.py:9: RuntimeWarning: invalid value encountered in scalar divide
  sigma = np.sqrt((2*lambd*T_i_1)/(1-np.exp(-2*lambd*T_i_1))) * vol / beta</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-34-output-2.png" width="614" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<ul>
<li><p>On observe qu’une mean reversion faible augmente la valeur de l’option. En effet, le taux se stabilise autour de sa moyenne de long terme, réduisant la probabilité de franchissement de la barrière.</p></li>
<li><p>À l’inverse, une mean reversion forte diminue la valeur de l’option, car elle rend le taux plus volatile et moins prévisible.</p></li>
</ul>
<hr>
<div id="361ce0a3" class="cell" data-execution_count="34">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">90</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>barrier <span class="op">=</span> L_0 <span class="op">+</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> L_0 <span class="op">-</span> <span class="dv">100</span><span class="op">/</span> <span class="dv">10_000</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>lambdas <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>, num<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>cap_mean_rev <span class="op">=</span> np.array([option_vanille_bermude(T <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]), delta <span class="op">=</span> <span class="dv">1</span>, K <span class="op">=</span> K,</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>                                                sig <span class="op">=</span> sigma(<span class="dv">5</span>, <span class="dv">6</span>, lambd, vol<span class="op">=</span>vol_imp), <span class="co"># On recalibre la vol pour chaque lambda</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>                                                lambd <span class="op">=</span> lambd,</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>                                                barrier <span class="op">=</span> barrier) <span class="cf">for</span> lambd <span class="kw">in</span> lambdas] )</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>plt.plot(lambdas, cap_mean_rev[:,<span class="dv">0</span>], label <span class="op">=</span><span class="st">"Prix de l'option"</span>)</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Mean reversion ($</span><span class="er">\</span><span class="st">lambda$)"</span>)</span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Prix de l'option"</span>)</span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Prix de l'option en fonction de la mean reversion"</span>)</span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>&lt;&gt;:25: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
&lt;&gt;:25: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2646903226.py:25: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
  plt.xlabel("Mean reversion ($\lambda$)")
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2512216972.py:7: RuntimeWarning: invalid value encountered in scalar divide
  beta = (1-np.exp(-lambd*(T_i - T_i_1)))/lambd
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2512216972.py:9: RuntimeWarning: invalid value encountered in scalar divide
  sigma = np.sqrt((2*lambd*T_i_1)/(1-np.exp(-2*lambd*T_i_1))) * vol / beta</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-35-output-2.png" width="614" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="ca770adb" class="cell" data-execution_count="35">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>lambdas <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>, num<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>vol_mean_rev <span class="op">=</span> np.array([sigma(<span class="dv">5</span>, <span class="dv">6</span>, lambd, vol<span class="op">=</span>vol_imp) <span class="cf">for</span> lambd <span class="kw">in</span> lambdas] )</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>plt.plot(lambdas, vol_mean_rev, label <span class="op">=</span><span class="st">"Volatilité instantanée"</span>)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Mean reversion ($</span><span class="er">\</span><span class="st">lambda$)"</span>)</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"volatilité"</span>)</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Volatilité instantanée en fonction de la mean reversion"</span>)</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>&lt;&gt;:9: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
&lt;&gt;:9: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\1203548000.py:9: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
  plt.xlabel("Mean reversion ($\lambda$)")
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2512216972.py:7: RuntimeWarning: invalid value encountered in scalar divide
  beta = (1-np.exp(-lambd*(T_i - T_i_1)))/lambd
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2512216972.py:9: RuntimeWarning: invalid value encountered in scalar divide
  sigma = np.sqrt((2*lambd*T_i_1)/(1-np.exp(-2*lambd*T_i_1))) * vol / beta</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-36-output-2.png" width="606" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<ol start="9" type="1">
<li><p>Probabilité d’atteinte de la barrière en fonction de la mean reversion</p>
<ul>
<li><p>On peut déduire de ce qui précède que la probabilité de toucher la barrière croît lorsque la mean reversion décroît.</p></li>
<li><p>Une estimation faite en valorisant l’option illutrer d’ailleurs cette analyse (voir figure i-dessous). Il apparaît clairement qu’il devient de plus en plus probable de franchir la barrière pour des mean reversion fortes.</p></li>
</ul></li>
</ol>
<p><strong>Il est à noter que ces observations faite pour la mean reversion et la probabilité d’atteinte de la barrière est inversée lorsque le modèle n’est pas recalibré pour chaque valeur de <span class="math inline">\(\lambda\)</span>.</strong></p>
<div id="11d66a4a" class="cell" data-execution_count="36">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>plt.plot(lambdas, cap_mean_rev[:,<span class="dv">1</span>],  linestyle<span class="op">=</span><span class="st">'-'</span>, color<span class="op">=</span><span class="st">'r'</span>, label<span class="op">=</span><span class="st">"Probabilité de toucher la barrière"</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Mean reversion ($</span><span class="er">\</span><span class="st">lambda$)"</span>)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Probabilité d'atteindre la barrière"</span>)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Impact de la Mean Reversion sur l'Atteinte de la Barrière"</span>)</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>&lt;&gt;:3: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
&lt;&gt;:3: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
C:\Users\mokom\AppData\Local\Temp\ipykernel_22344\2478896390.py:3: SyntaxWarning: "\l" is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\l"? A raw string is also an option.
  plt.xlabel("Mean reversion ($\lambda$)")</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="projet_courbe_taux_files/figure-html/cell-37-output-2.png" width="589" height="451" class="figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>