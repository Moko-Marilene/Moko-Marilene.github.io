---
title: "Calibration du modèle de Black-Scholes"
author: "KOUGOUM Marilene"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
execute:
  echo: true
  warning: false
  message: false
---

[⬅ Retour](../index.qmd)


# Introduction

Nous nous intéressons ici au modèle de **Black–Scholes** pour le pricing d’options européennes d’achat (calls) et à la notion de **calibration** du modèle via la volatilité implicite.

L’objectif est de :

- rappeler la formule fermée de Black–Scholes pour le prix d’un call ;
- comparer ce prix avec une **approximation par Monte Carlo** ;
- calculer les **Greeks** (Delta, Gamma, Vega) :
  - analytiquement,
  - numériquement (différences finies),
  - par Monte Carlo ;
- déterminer la **volatilité implicite**.

On suppose que le sous-jacent suit un **mouvement brownien géométrique** :

$$
dS_t = \mu S_t\,dt + \sigma S_t\,dW_t
$$

Sous la mesure risque-neutre, le drift devient $r$.

```{python}
import numpy as np
from scipy.stats import norm
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
```

# 1. Prix d’un call par la formule de Black–Scholes

## 1.1 Formule fermée

Pour un call de strike $K$ et maturité $\tau$ :

$$
C(S,K,r,\sigma,\tau) = S\,N(d_1) - K e^{-r\tau} N(d_2)
$$

Avec :

$$
d_1 = \frac{\ln(S/K) + (r + \tfrac12\sigma^2)\tau}{\sigma\sqrt{\tau}},
\qquad
d_2 = d_1 - \sigma\sqrt{\tau}
$$

## 1.2 Implémentation

```{python}
def Call(S, K, r, tau, sigma):
    """
    Prix d'un call européen par la formule de Black–Scholes.
    """
    d1 = (np.log(S/K) + (r + 0.5 * sigma**2) * tau) / (sigma * np.sqrt(tau))
    d2 = d1 - sigma * np.sqrt(tau)
    C = S * norm.cdf(d1) - K * np.exp(-r * tau) * norm.cdf(d2)
    return C
```

# 2. Pricing par Monte Carlo

## 2.1 Idée

Sous Black–Scholes :

$$
S_\tau = S_0 \exp\!\left((r - \tfrac12\sigma^2)\tau + \sigma W_\tau\right),
\qquad W_\tau \sim N(0,\tau)
$$

Le prix Monte Carlo :

$$
C \approx e^{-r\tau}\,\mathbb{E}[(S_\tau - K)^+]
$$

## 2.2 Implémentation

```{python}
def MonteCarlo(r, sigma, tau, M, K, S0):
    sigma_T = sigma * np.sqrt(tau)
    Z = np.random.normal(0, sigma_T, M)
    S_T = S0 * np.exp((r - 0.5 * sigma**2) * tau + Z)
    payoff = np.maximum(S_T - K, 0)
    return np.exp(-r * tau) * np.mean(payoff)
```

# 3. Comparaison BS vs Monte Carlo

## 3.1 Cas $\tau = 6$

```{python}
S = 42
K = 40
r = 0.1
tau = 6
sigma = 0.2

print("BS =", Call(S, K, r, tau, sigma))
```

Monte Carlo :

```{python}
for M in [500, 5000, 50000]:
    print(M, MonteCarlo(r, sigma, tau, M, K, S))
```

## 3.1 Cas $\tau = 3$

```{python}
S = 42
K = 40
r = 0.1
tau = 3
sigma = 0.2

print("BS =", Call(S, K, r, tau, sigma))
```

Monte Carlo :

```{python}
for M in [500, 5000, 50000]:
    print(M, MonteCarlo(r, sigma, tau, M, K, S))
```

# 4. Greeks

## 4.1 Définitions

$$
\Delta = \frac{\partial C}{\partial S},
\qquad
\Gamma = \frac{\partial^2 C}{\partial S^2},
\qquad
\text{Vega} = \frac{\partial C}{\partial\sigma}
$$

## 4.2 Formules analytiques

```{python}
def FormulaBSGreeks(S, K, r, tau, sigma):
    d1 = (np.log(S/K)+(r+0.5*sigma**2)*tau)/(sigma*np.sqrt(tau))
    pdf = np.exp(-d1**2/2)/np.sqrt(2*np.pi)

    delta = norm.cdf(d1)
    gamma = pdf / (S * sigma * np.sqrt(tau))
    vega  = S * np.sqrt(tau) * pdf

    return delta, gamma, vega

S = 100
K = 110
r = 0
sigma = 0.2
tau = 0.5

FormulaBSGreeks(S, K, r, tau, sigma)
```

# 5. Greeks par différences finies

Approximation :

$$
\Delta \approx \frac{C(S+h) - C(S-h)}{2h}
$$

$$
\Gamma \approx \frac{C(S+h) - 2C(S) + C(S-h)}{h^2}
$$

```{python}
def Greeks_diff(S, K, r, tau, sigma, h=1e-4):
    delta = (Call(S+h,K,r,tau,sigma)-Call(S-h,K,r,tau,sigma))/(2*h)
    gamma = (Call(S+h,K,r,tau,sigma)-2*Call(S,K,r,tau,sigma)+Call(S-h,K,r,tau,sigma))/(h**2)
    vega  = (Call(S,K,r,tau,sigma+h)-Call(S,K,r,tau,sigma-h))/(2*h)
    return delta, gamma, vega

Greeks_diff(S, K, r, tau, sigma)
```

# 6. Greeks par Monte Carlo

## 6.1 Formules MC

Approximation pathwise pour $\Delta$, LR pour Vega.

```{python}
def Greeks_Monte_Carlo(r, sigma, tau, M, K, S0):
    d1 = (np.log(S0/K)+(r+0.5*sigma**2)*tau)/(sigma*np.sqrt(tau))

    sigma_T = sigma*np.sqrt(tau)
    Z = np.random.normal(0, sigma_T, M)
    S_T = S0*np.exp((r-0.5*sigma**2)*tau + Z)

    delta_MC = np.exp(-r*tau)*np.mean((S_T > K)*(S_T/S0))
    gamma_MC = np.exp(-d1**2/2)/(S0*sigma*np.sqrt(2*np.pi*tau))
    vega_MC  = np.exp(-r*tau)*np.mean((S_T > K)*(S_T/sigma)*(np.log(S_T/S0)-(r-0.5*sigma**2)*tau))

    return delta_MC, gamma_MC, vega_MC

Greeks_Monte_Carlo(r, sigma, tau, 10000, K, S)
```

# 7. Volatilité implicite

## 7.1 Définition

Trouver $\sigma$ tel que :

$$
C^{BS}(S,K,r,\sigma,\tau) = C^{\text{marché}}
$$

## 7.2 Implémentation

```{python}
def ImpliedVolBS(S, K, r, tau, call):
    def f(sigma):
        return Call(S, K, r, tau, sigma) - call
    return fsolve(f, 0.2)[0]
```

## 7.3 Exemples

```{python}
print(ImpliedVolBS(100, 100, 0.05, 1/4, 4.58))
print(ImpliedVolBS(100, 100, 0.05, 1/2, 5.53))
```
